<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ME4918 机械工程本科毕业设计</title>
    <url>//13599.html</url>
    <content><![CDATA[<style type="text/css">
    .fancybox {
        display: inline-block;
    }
</style>

<center>
  <font size=5>
    <b>基于医用物品抓取的3D图像分割、姿态估计和环境理解</b>
  </font>
</center>


<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>&emsp;&emsp;生物样本库通常用来保存血液、基因、代谢产物等珍贵的生物样本。生物样本保存在冻存盒内的冻存管中，并整盒存放于-80°甚至-196°的深低温环境中。为提高存取效率，当用户需要提取样本时，由自动化设备将存有目标样本的冻存盒取出，并使用机械臂夹取目标样本到空冻存盒中完成样本出库，并在-30°环境下使用挑管夹爪夹取目标样本到空冻存盒中完成样本出库。深低温保存条件下，冻存盒体表面会逐渐结霜。在零度以下的工作环境中反复移动、定位和出入库的过程，会导致结霜表面逐渐增厚，盒体发生轻微滑动，盒底孔位结霜干扰识别。长期使用中会导致挑管时盒体定位精度下降，夹爪取放位置误差增大，造成挑管成功率下降，严重时可能损坏样本，造成重大的损失。另外，当出现样本管倾倒等异常情况时，难以通过孔位识别进行定位抓取，也会导致挑管失败。  </p>
<p>&emsp;&emsp;因此，项目需要一套<b>视觉辅助的机械臂挑管系统</b>，能够实现精准的抓取与稳定的路径规划，同时在检测到样本管异常情况时控制机械臂调整样本管位姿并放置到目标位置。在正常工作环境下，机械臂3轴移动即可实现样本管的平稳运送。但在样本管异常放置情况下，倾斜样本管的位姿调整与移送要求机械臂实现6自由度动作，并能够基于环境理解进行智能抓取。</p>
<div style="display:inline-block;">
    <img src="\images\ME4918-机械工程本科毕业设计\pic01.png" alt="pic01" style="display: block; margin: 0 auto; float: center;" width="30%">
</div>

<center>
  <font size=3>
    图 - 项目应用场景
  </font>
</center>



<h2 id="个人分工"><a href="#个人分工" class="headerlink" title="个人分工"></a>个人分工</h2><p>&emsp;&emsp;在本项目中，我将综合应用3D视觉技术和深度学习算法，解决不同形态和大小的医用物品在复杂环境中的抓取问题。首先，通过高效的图像分割技术，我们能够准确地将目标物品从其环境中区分出来，为抓取任务提供了精确的空间定位。进而，利用高级的姿态估计算法，系统能够计算出机械臂执行任务时的最优姿态，确保安全、精确的抓取。最后，通过智能规划，系统得以确定最佳的抓取顺序，旨在优化作业效率和成功率。整个系统的设计均考虑到边缘计算环境的资源限制，确保所有计算过程能在英伟达Orin边缘计算模块上以5hz以上的速度运行，展示了在现代自动化医疗场景中3D视觉技术的巨大潜力和实用价值。</p>
<ol>
<li><strong>抓取物品的图像分割</strong></li>
</ol>
<p>&emsp;&emsp;在复杂的医疗物品抓取任务中，准确的图像分割是实现高效抓取的关键。面对各种形态和尺寸的医用物品（如疫苗管、试管等），我们首先要利用3D视觉技术精确地将这些物品从背景中分割出来。这一步骤需要处理可能出现的物体间遮挡、光照变化以及物体本身的反光材质等问题。图像分割算法需要有足够的鲁棒性，以适应医疗环境中多变的条件。通过对3D点云数据的深度学习处理，能够实现对各种医用物品和它们的空间位置的精确识别，从而为后续的抓取姿态估计和序列规划提供可靠的前处理数据。</p>
<ol>
<li><strong>机械臂最佳抓取姿态估计</strong></li>
</ol>
<p>&emsp;&emsp;根据图像分割结果，系统需要进一步估计机械臂的最佳抓取姿态。使用3D视觉技术构建目标物体的高精度立体模型，结合机器学习算法对抓取点的稳定性和可行性进行评估。抓取姿态涉及到物体的方向、机械臂的接近角度和路径规划等多个要素。我们当中采用优化算法来确保最终推导出的抓取姿态既能增强抓取的成功率，又能最大限度减少机械臂的运动时间和能耗。姿态估计模块必须实时工作，以适应动态变化的抓取环境和任务需求。</p>
<ol>
<li><strong>医疗物品抓取顺序的计算</strong></li>
</ol>
<p>&emsp;&emsp;确定合理的抓取顺序对于提高整体抓取效率和成功率具有至关重要的意义。考虑到各种医疗物品之间的空间布局和相互关联，系统需要计算出一个最优的抓取顺序。这一过程包含复杂的逻辑和规划算法，例如，可能需要优先抓取会对后续操作造成遮挡的物品，或者根据任务紧急性来调整抓取顺序。适配边缘计算的算法需要考虑到计算资源和响应时间的限制，确保在有限的硬件资源下也能够快速给出最优解决方案。</p>
<h2 id="文献调研-开题答辩"><a href="#文献调研-开题答辩" class="headerlink" title="文献调研+开题答辩"></a>文献调研+开题答辩</h2><p>（见如下文件）</p>
<p><a href="https://xcdai.xyz/files/2024144+3D视觉识别及其在机器人抓取中的应用+开题报告.pdf">3D视觉识别及其在机器人抓取中的应用-开题报告.pdf</a></p>
<p><a href="https://xcdai.xyz/files/2024144+3D视觉识别及其在机器人抓取中的应用+开题答辩PPT.pdf">3D视觉识别及其在机器人抓取中的应用-开题答辩PPT.pdf</a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="硬件层面"><a href="#硬件层面" class="headerlink" title="硬件层面"></a>硬件层面</h3><ul>
<li><p>NVIDIA Jetson Orin NX 16GB</p>
<p>配备了高性能的英伟达GPU和多核CPU，算力高达每秒275万亿次浮点运算(TOPS)，适合处理复杂的深度学习任务；提供了多种I/O接口和丰富的软件生态；同时具有紧凑的尺寸和优秀的能效比。</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic02.png" alt="pic02" style="zoom:50%;"></p>
</li>
<li><p>ZED 2i双目深度相机</p>
<p>具备高精度的深度感知能力，拥有广泛的视场(FOV)，提供高分辨率的RGB图像；支持Jetson L4T操作系统，提供了全面的软件开发工具包(SDK)，并为特定AI应用做了优化。</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic03.png" alt="pic03" style="zoom:80%;"></p>
</li>
<li><p>12V 5A电源适配器</p>
</li>
<li>罗技MK275无线键鼠</li>
<li>Redmi显示器A24-100hz</li>
</ul>
<div style="display:inline-block;">
    <img src="\images\ME4918-机械工程本科毕业设计\pic04.jpg" alt="pic04" style="display: block; margin: 0 auto; float: center;" width="30%">
</div>

<center>
  <font size=3>
    图 - 硬件搭建效果展示
  </font>
</center>

<h3 id="软件层面"><a href="#软件层面" class="headerlink" title="软件层面"></a>软件层面</h3><ul>
<li><p>安装Nvidia Jetpack</p>
<p>Nvidia Jetpack是专为Jetson平台设计的构建人工智能应用的全面的解决方案，它包括带有引导程序的Linux驱动程序包、Linux内核、Ubuntu桌面环境，以及一整套用于加速GPU计算、多媒体、图形和计算机视觉的库。参考<a href="https://developer.nvidia.com/embedded/learn/get-started-jetson-agx-orin-devkit">英伟达官方教程</a>，用命令行方式安装jetpack</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">sudo reboot</span><br><span class="line">sudo apt install nvidia-jetpack</span><br></pre></td></tr></table></figure>
<p>执行最后一步命令出现报错：</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic05.png" style="zoom:100%;"/></p>
<p>解决办法：<strong>为系统源增加英伟达镜像源</strong></p>
<ol>
<li><p>首先查看Tegra处理器的Linux操作系统版本：<code>cat /etc/nv_tegra_release</code></p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic06.png" style="zoom:100%;"/></p>
<p>可以看到是L4T 35.3的版本</p>
</li>
<li><p>然后<code>sudo gedit /etc/apt/sources.list.d/nvidia-l4t-apt-source.list</code></p>
</li>
<li><p>在文件中添加以下两行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://repo.download.nvidia.com/jetson/common r35.3 main</span><br><span class="line">deb https://repo.download.nvidia.com/jetson/t234 r35.3 main</span><br></pre></td></tr></table></figure>
<p>保存后关闭</p>
</li>
<li><p>重启系统后重新执行前文的命令行即可</p>
</li>
</ol>
</li>
<li><p>安装jtop监控工具</p>
<p>jtop是Jetson系列著名的系统监控工具，安装过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo -H pip3 install -U pip</span><br><span class="line">sudo -H pip install jetson-stats</span><br><span class="line">jtop</span><br></pre></td></tr></table></figure>
<p>执行完最后一条命令，可显示包含CPU、GPU、内存和磁盘等实时情况的图形界面</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic07.png" style="zoom:70%;"/></p>
</li>
<li><p>为CUDA设置环境变量</p>
<p>在终端中修改bashrc文件，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文末添加如下代码</span></span><br><span class="line">export PATH=/usr/local/cuda/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export CUDA_HOME=/usr/local/cuda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新环境变量配置</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>检验CUDA环境配置成功：<code>nvcc -V</code></p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic08.png" style="zoom:85%;"/></p>
</li>
<li><p>配置CuDNN环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制文件到cuda目录下</span></span><br><span class="line">cd /usr/include &amp;&amp; sudo cp cudnn* /usr/local/cuda/include</span><br><span class="line">cd /usr/lib/aarch64-linux-gnu &amp;&amp; sudo cp libcudnn* /usr/local/cuda/lib64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件权限</span></span><br><span class="line">sudo chmod 774 /usr/local/cuda/include/cudnn.h</span><br><span class="line">sudo chmod 774 /usr/local/cuda/lib64/libcudnn*</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新软链接（8.6.0为cudnn版本号）</span></span><br><span class="line">cd /usr/local/cuda/lib64</span><br><span class="line">sudo ln -sf libcudnn.so.8.6.0 libcudnn.so.8</span><br><span class="line">sudo ln -sf libcudnn_ops_train.so.8.6.0 libcudnn_ops_train.so.8</span><br><span class="line">sudo ln -sf libcudnn_ops_infer.so.8.6.0 libcudnn_ops_infer.so.8</span><br><span class="line">sudo ln -sf libcudnn_adv_train.so.8.6.0 libcudnn_adv_train.so.8</span><br><span class="line">sudo ln -sf libcudnn_adv_infer.so.8.6.0 libcudnn_adv_infer.so.8</span><br><span class="line">sudo ln -sf libcudnn_cnn_train.so.8.6.0 libcudnn_cnn_train.so.8</span><br><span class="line">sudo ln -sf libcudnn_cnn_infer.so.8.6.0 libcudnn_cnn_infer.so.8</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>检验CuDNN环境配置成功：<code>dpkg -l libcudnn8</code></p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic09.png" style="zoom:80%;"/></p>
</li>
<li><p>安装Anaconda虚拟环境</p>
<p>使用<a href="https://repo.anaconda.com/archive">清华镜像源</a>下载Anaconda，根据系统版本选择最新的<strong>Anaconda3-2023.09-0-Linux-aarch64.sh</strong>，按照提示安装并运行即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda --version   # conda 23.11.0</span><br><span class="line">conda create -n ZED_Python python=3.8</span><br><span class="line">source activate ZED_Python</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装ZED SDK</p>
<p>在<a href="https://www.stereolabs.com/developers/release#82af3640d775">stereolabs官网</a>选择适合系统版本的文件下载，然后执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zstd</span><br><span class="line">./ZED_SDK_Tegra_L4T35.3_v4.0.8.zstd.run</span><br></pre></td></tr></table></figure>
<p>在安装ZED Python API的过程中遇到报错：</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic10.png" style="zoom:80%;"/></p>
<p>可能是连接服务器超时导致的，手动下载whl二进制文件并安装，注释掉相应代码重新执行命令并成功。</p>
<p>接下来测试Jetson和ZED硬件连接是否畅通：</p>
<p>首先应确保将相机插入<strong>USB3.0端口</strong>（内部有蓝色标记），以保证足够的带宽和传输速度；其次需从<a href="https://www.stereolabs.com/developers/calib">官网</a>下载<strong>校准文件</strong>至安装目录的settings文件夹，该文件包含有关左右相机的精确位置及其光学特性的信息，是深度估计过程的关键（获取相机序列号的命令：<code>ZED_Explorer --all</code>）</p>
<p>最后运行<code>/usr/local/zed/tools</code>目录下的应用程序<strong>ZED_Explorer</strong>和<strong>ZED_Depth_Viewer</strong>，运行效果如下：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>ZED_Explorer</strong></th>
<th style="text-align:center"><strong>ZED_Depth_Viewer</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="\images\ME4918-机械工程本科毕业设计\pic11.png" style="zoom:50%;"/></td>
<td style="text-align:center"><img src="\images\ME4918-机械工程本科毕业设计\pic12.png" style="zoom:50%;"/></td>
</tr>
</tbody>
</table>
</div>
<h2 id="第一部分：图像分割"><a href="#第一部分：图像分割" class="headerlink" title="第一部分：图像分割"></a>第一部分：图像分割</h2><p>&emsp;&emsp;本部分的阶段性目标：通过3D视觉技术将试管及冻存盒从背景中分割出来，实现对目标试管的精准定位，为机械臂抓取姿态的估计做准备性工作。本部分要求图像分割算法具有足够的<strong>鲁棒性</strong>，以适应物体间遮挡、光照变化以及反光材质等复杂的应用环境。</p>
<h3 id="Hough圆变换"><a href="#Hough圆变换" class="headerlink" title="Hough圆变换"></a>Hough圆变换</h3><p>&emsp;&emsp;本项目将主摄像头安装在试管底部负责定位孔位，机械臂上的备用摄像头用于试管抓取异常时的排障。考虑到试管底部呈圆形，且粘有白色贴纸与黑色冻存盒能产生强烈反差，故联想到使用<strong>Canny边缘检测器</strong>和<strong>Hough圆变换</strong>的方法定位试管。</p>
<p>&emsp;&emsp;Canny边缘检测可分为以下四个步骤：</p>
<ol>
<li><strong>去除噪声</strong>：使用高斯滤波器对图像进行平滑处理以减少噪声。将二维高斯函数离散化后，即得高斯滤波器的计算公式${G(x, y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}}$，其中${G(x,y)}$是一个像素点，${\sigma}$是高斯滤波器的标准差.</li>
<li><strong>梯度计算</strong>：计算图像中每个像素点的梯度强度和方向，常通过Sobel算子来完成。</li>
<li><strong>非极大值抑制</strong>：遍历梯度矩阵上的所有点，并保留边缘方向上具有极大值的像素为边缘候选点，否则将该点的梯度值设置为0，以消除对边缘检测的影响。</li>
<li><strong>双阈值检测和边缘连接</strong>：通过设定高低两个阈值来识别强边缘和弱边缘。强边缘是确定的边缘点，而弱边缘则可能是边缘也可能不是。若弱边缘与强边缘相连，则认为它是真正的边缘；否则，将其抑制。</li>
</ol>
<p>&emsp;&emsp;在边缘检测的基础上，霍夫变换原理可用于在图像中识别圆形物体，具体步骤如下：</p>
<ol>
<li><strong>霍夫空间映射</strong>：在霍夫空间中，每个边缘点可以表示为一系列可能的圆，这些圆有不同的中心和半径。在霍夫空间中，这转化为在三维空间（圆心的x坐标、y坐标和半径）上的一个点集。</li>
<li><strong>累加器</strong>：在霍夫空间中，为每个可能的圆心和半径设置一个累加器。每次一个边缘点在霍夫空间中对应一个圆时，该圆的累加器值就增加。</li>
<li><strong>寻找显著圆</strong>：在累加器中，值最大的点对应的圆心和半径被选为实际存在的圆。通过设定一个阈值可确定哪些累加器值足够高时可以表示一个圆。</li>
</ol>
<p>&emsp;&emsp;霍夫圆检测特别适用于图像中圆形物体的位置不明确或有部分遮挡的情况。通过霍夫变换，即使只有圆的一部分边缘可见，也能有效地检测出完整的圆。</p>
<p>&emsp;&emsp;结合opencv的HoughCircles函数和ZED提供的python API，编写代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HoughCircles.py</span></span><br><span class="line"><span class="keyword">import</span> pyzed.sl <span class="keyword">as</span> sl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Create a Camera object</span></span><br><span class="line">    zed = sl.Camera()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a InitParameters object and set configuration parameters</span></span><br><span class="line">    init_params = sl.InitParameters()</span><br><span class="line">    init_params.camera_resolution = sl.RESOLUTION.HD1080</span><br><span class="line">    init_params.camera_fps = <span class="number">30</span></span><br><span class="line">    init_params.depth_mode = sl.DEPTH_MODE.ULTRA  <span class="comment"># Use ULTRA depth mode</span></span><br><span class="line">    init_params.coordinate_units = sl.UNIT.METER  <span class="comment"># Use millimeter units (for depth measurements)</span></span><br><span class="line">    init_params.depth_minimum_distance = <span class="number">0.15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Open the camera</span></span><br><span class="line">    status = zed.<span class="built_in">open</span>(init_params)</span><br><span class="line">    <span class="keyword">if</span> status != sl.ERROR_CODE.SUCCESS:  <span class="comment"># Ensure the camera has opened successfullys</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Camera Open : &quot;</span> + <span class="built_in">repr</span>(status) + <span class="string">&quot;. Exit program.&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    image = sl.Mat()</span><br><span class="line">    pointcloud = sl.Mat()</span><br><span class="line">    runtime = sl.RuntimeParameters()  <span class="comment"># Create and set RuntimeParameters after opening the camera</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># A new image&#x27;s available if grab() returns success</span></span><br><span class="line">        <span class="keyword">if</span> zed.grab(runtime) == sl.ERROR_CODE.SUCCESS:</span><br><span class="line">            <span class="comment"># Retrieve left image</span></span><br><span class="line">            zed.retrieve_image(image, sl.VIEW.LEFT)</span><br><span class="line">            <span class="comment"># Retrieve colored point cloud that is aligned on the left image</span></span><br><span class="line">            zed.retrieve_measure(pointcloud, sl.MEASURE.XYZRGBA)</span><br><span class="line">            </span><br><span class="line">            img = image.get_data()</span><br><span class="line">            img = cv2.resize(img, (<span class="number">1280</span>,<span class="number">720</span>))</span><br><span class="line">            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">            gray = cv2.medianBlur(gray, <span class="number">3</span>)</span><br><span class="line">            circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>,</span><br><span class="line">                                       param1=<span class="number">50</span>, param2=<span class="number">30</span>, minRadius=<span class="number">10</span>, maxRadius=<span class="number">20</span>)</span><br><span class="line">            <span class="keyword">if</span> circles <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                circles = np.uint16(np.around(circles))</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">                    x, y = <span class="built_in">int</span>(i[<span class="number">0</span>]), <span class="built_in">int</span>(i[<span class="number">1</span>])</span><br><span class="line">                    <span class="comment"># draw the outer circle</span></span><br><span class="line">                    cv2.circle(img, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">                    <span class="comment"># draw the center of the circle</span></span><br><span class="line">                    cv2.circle(img, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                    err, point_value = pointcloud.get_value(x, y)</span><br><span class="line">                    <span class="keyword">if</span> math.isfinite(point_value[<span class="number">2</span>]):</span><br><span class="line">                        distance = math.sqrt(point_value[<span class="number">0</span>]**<span class="number">2</span>+point_value[<span class="number">1</span>]**<span class="number">2</span>+point_value[<span class="number">2</span>]**<span class="number">2</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Distance to Camera at (<span class="subst">&#123;i[<span class="number">0</span>]&#125;</span>,<span class="subst">&#123;i[<span class="number">1</span>]&#125;</span>): <span class="subst">&#123;distance&#125;</span> m.&quot;</span>)</span><br><span class="line"></span><br><span class="line">            cv2.imshow(<span class="string">&quot;detected circles&quot;</span>, img)</span><br><span class="line">            key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> key &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):  <span class="comment"># Press &#x27;q&#x27; to exit</span></span><br><span class="line">                zed.close() <span class="comment"># Close the camera</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实际运行效果如下：</p>
<video src="\images\ME4918-机械工程本科毕业设计\HoughCircles.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"></video>



<h3 id="AprilTag"><a href="#AprilTag" class="headerlink" title="AprilTag"></a>AprilTag</h3><p>&emsp;&emsp;AprilTag是一个免费开源的视觉定位系统，用于物体的识别、定位和姿态估计，在增强现实、机器人、相机校准等领域广泛使用。Apriltag的设计旨在通过识别特定的二维码标记，快速检测并计算出相机相对于标记的位置和方向。</p>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><p>&emsp;&emsp;在Conda虚拟环境中通过CMake安装第三方库过程如下：（附<a href="https://github.com/AprilRobotics/apriltag">Github Repo</a>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/AprilRobotics/apriltag</span><br><span class="line">cd apriltag</span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$CONDA_PREFIX</span><br><span class="line">cmake --build build --target install</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译libopencv时出现报错：</p>
<p><img src="\images\ME4918-机械工程本科毕业设计\pic13.png" style="zoom:80%;"/></p>
<p>&emsp;&emsp;分析：在系统python解释器和conda环境中同时安装了libopencv，同时创建了两个关于libopencv的cmake文件（且两个版本不兼容），在编译的时候有<code>find_package(OpenCV ...)</code>，这一步本应寻找<code>/usr/lib/x86_64-linux-gnu/cmake/opencv4/OpenCVConfig.cmake</code>这个文件，但由于安装了anaconda这一步变为寻找<code>$&#123;CONDA_PREFIX&#125;/lib/cmake/opencv4/OpenCVConfig.cmake</code>这个文件，导致后续编译时链接的库文件出错。解决方法是<strong>限定要寻找的Qt5config.cmake文件路径</strong>，即在CMakeLists.txt里添加<code>SET(CMAKE_PREFIX_PATH &quot;/usr/lib/x86_64-linux-gnu/cmake&quot;)</code>，重新编译即可解决问题。</p>
<h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        apriltag.py
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python wrapper for C version of apriltags. This program creates two</span></span><br><span class="line"><span class="string">classes that are used to detect apriltags and extract information from</span></span><br><span class="line"><span class="string">them. Using this module, you can identify all apriltags visible in an</span></span><br><span class="line"><span class="string">image, and get information about the location and orientation of the</span></span><br><span class="line"><span class="string">tags.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Original author: Isaac Dulin, Spring 2016</span></span><br><span class="line"><span class="string">Updates: Matt Zucker, Fall 2016</span></span><br><span class="line"><span class="string">Updates: Tinker Twins, Spring 2021</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ImageU8</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps image_u8 C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;width&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;height&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;stride&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;buf&#x27;</span>, ctypes.POINTER(ctypes.c_uint8))</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Matd</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps matd C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;nrows&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;ncols&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;data&#x27;</span>, ctypes.c_double*<span class="number">1</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ZArray</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps zarray C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;el_sz&#x27;</span>, ctypes.c_size_t),</span><br><span class="line">        (<span class="string">&#x27;size&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;alloc&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;data&#x27;</span>, ctypes.c_void_p)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ApriltagFamily</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps apriltag_family C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;ncodes&#x27;</span>, ctypes.c_int32),</span><br><span class="line">        (<span class="string">&#x27;codes&#x27;</span>, ctypes.POINTER(ctypes.c_int64)),</span><br><span class="line">        (<span class="string">&#x27;black_border&#x27;</span>, ctypes.c_int32),</span><br><span class="line">        (<span class="string">&#x27;d&#x27;</span>, ctypes.c_int32),</span><br><span class="line">        (<span class="string">&#x27;h&#x27;</span>, ctypes.c_int32),</span><br><span class="line">        (<span class="string">&#x27;name&#x27;</span>, ctypes.c_char_p),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ApriltagDetection</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps apriltag_detection C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;family&#x27;</span>, ctypes.POINTER(_ApriltagFamily)),</span><br><span class="line">        (<span class="string">&#x27;id&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;hamming&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;goodness&#x27;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&#x27;decision_margin&#x27;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&#x27;H&#x27;</span>, ctypes.POINTER(_Matd)),</span><br><span class="line">        (<span class="string">&#x27;c&#x27;</span>, ctypes.c_double*<span class="number">2</span>),</span><br><span class="line">        (<span class="string">&#x27;p&#x27;</span>, (ctypes.c_double*<span class="number">2</span>)*<span class="number">4</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ApriltagDetector</span>(ctypes.Structure):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Wraps apriltag_detector C struct.&#x27;&#x27;&#x27;</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&#x27;nthreads&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;quad_decimate&#x27;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&#x27;quad_sigma&#x27;</span>, ctypes.c_float),</span><br><span class="line">        (<span class="string">&#x27;refine_edges&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;refine_decode&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;refine_pose&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;debug&#x27;</span>, ctypes.c_int),</span><br><span class="line">        (<span class="string">&#x27;quad_contours&#x27;</span>, ctypes.c_int),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_ptr_to_array2d</span>(<span class="params">datatype, ptr, rows, cols</span>):</span><br><span class="line">    array_type = (datatype*cols)*rows</span><br><span class="line">    array_buf = array_type.from_address(ctypes.addressof(ptr))</span><br><span class="line">    <span class="keyword">return</span> numpy.ctypeslib.as_array(array_buf, shape=(rows, cols))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_image_u8_get_array</span>(<span class="params">img_ptr</span>):</span><br><span class="line">    <span class="keyword">return</span> _ptr_to_array2d(ctypes.c_uint8,</span><br><span class="line">                           img_ptr.contents.buf.contents,</span><br><span class="line">                           img_ptr.contents.height,</span><br><span class="line">                           img_ptr.contents.stride)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_matd_get_array</span>(<span class="params">mat_ptr</span>):</span><br><span class="line">    <span class="keyword">return</span> _ptr_to_array2d(ctypes.c_double,</span><br><span class="line">                           mat_ptr.contents.data,</span><br><span class="line">                           <span class="built_in">int</span>(mat_ptr.contents.nrows),</span><br><span class="line">                           <span class="built_in">int</span>(mat_ptr.contents.ncols))</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line">DetectionBase = collections.namedtuple(</span><br><span class="line">    <span class="string">&#x27;DetectionBase&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tag_family, tag_id, hamming, goodness, decision_margin, &#x27;</span></span><br><span class="line">    <span class="string">&#x27;homography, center, corners&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Detection</span>(<span class="title class_ inherited__">DetectionBase</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Pythonic wrapper for apriltag_detection which derives from named</span></span><br><span class="line"><span class="string">    tuple class.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    _print_fields = [</span><br><span class="line">        <span class="string">&#x27;Family&#x27;</span>, <span class="string">&#x27;ID&#x27;</span>, <span class="string">&#x27;Hamming error&#x27;</span>, <span class="string">&#x27;Goodness&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Decision margin&#x27;</span>, <span class="string">&#x27;Homography&#x27;</span>, <span class="string">&#x27;Center&#x27;</span>, <span class="string">&#x27;Corners&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    _max_len = <span class="built_in">max</span>(<span class="built_in">len</span>(field) <span class="keyword">for</span> field <span class="keyword">in</span> _print_fields)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tostring</span>(<span class="params">self, values=<span class="literal">None</span>, indent=<span class="number">0</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;Converts this object to a string with the given level of indentation.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        rval = []</span><br><span class="line">        indent_str = <span class="string">&#x27; &#x27;</span>*(self._max_len+<span class="number">2</span>+indent)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">            values = collections.OrderedDict(<span class="built_in">zip</span>(self._print_fields, self))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> values:</span><br><span class="line"></span><br><span class="line">            value_str = <span class="built_in">str</span>(values[label])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> value_str.find(<span class="string">&#x27;\n&#x27;</span>) &gt; <span class="number">0</span>:</span><br><span class="line">                value_str = value_str.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                value_str = [value_str[<span class="number">0</span>]] + [indent_str+v <span class="keyword">for</span> v <span class="keyword">in</span> value_str[<span class="number">1</span>:]]</span><br><span class="line">                value_str = <span class="string">&#x27;\n&#x27;</span>.join(value_str)</span><br><span class="line"></span><br><span class="line">            rval.append(<span class="string">&#x27;&#123;:&gt;&#123;&#125;s&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                label, self._max_len+indent, value_str))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(rval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tostring().encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DetectorOptions</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Convience wrapper for object to pass into Detector</span></span><br><span class="line"><span class="string">    initializer. You can also pass in the output of an</span></span><br><span class="line"><span class="string">    argparse.ArgumentParser on which you have called add_arguments.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 families=<span class="string">&#x27;tag36h11&#x27;</span>,</span></span><br><span class="line"><span class="params">                 border=<span class="number">1</span>,</span></span><br><span class="line"><span class="params">                 nthreads=<span class="number">4</span>,</span></span><br><span class="line"><span class="params">                 quad_decimate=<span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">                 quad_blur=<span class="number">0.0</span>,</span></span><br><span class="line"><span class="params">                 refine_edges=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                 refine_decode=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 refine_pose=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 debug=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 quad_contours=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">        self.families = families</span><br><span class="line">        self.border = <span class="built_in">int</span>(border)</span><br><span class="line"></span><br><span class="line">        self.nthreads = <span class="built_in">int</span>(nthreads)</span><br><span class="line">        self.quad_decimate = <span class="built_in">float</span>(quad_decimate)</span><br><span class="line">        self.quad_sigma = <span class="built_in">float</span>(quad_blur)</span><br><span class="line">        self.refine_edges = <span class="built_in">int</span>(refine_edges)</span><br><span class="line">        self.refine_decode = <span class="built_in">int</span>(refine_decode)</span><br><span class="line">        self.refine_pose = <span class="built_in">int</span>(refine_pose)</span><br><span class="line">        self.debug = <span class="built_in">int</span>(debug)</span><br><span class="line">        self.quad_contours = quad_contours</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_arguments</span>(<span class="params">parser</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Add arguments to the given argparse.ArgumentParser object to enable</span></span><br><span class="line"><span class="string">    passing in the resulting parsed arguments into the initializer for</span></span><br><span class="line"><span class="string">    Detector.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    defaults = DetectorOptions()</span><br><span class="line"></span><br><span class="line">    show_default = <span class="string">&#x27; (default %(default)s)&#x27;</span></span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, metavar=<span class="string">&#x27;FAMILIES&#x27;</span>,</span><br><span class="line">                        dest=<span class="string">&#x27;families&#x27;</span>, default=defaults.families,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Tag families&#x27;</span> + show_default)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-B&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        dest=<span class="string">&#x27;border&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=defaults.border,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Tag border size in pixels&#x27;</span> + show_default)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-t&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        dest=<span class="string">&#x27;nthreads&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=defaults.nthreads,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Number of threads&#x27;</span> + show_default)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-x&#x27;</span>, metavar=<span class="string">&#x27;SCALE&#x27;</span>,</span><br><span class="line">                        dest=<span class="string">&#x27;quad_decimate&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">                        default=defaults.quad_decimate,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Quad decimation factor&#x27;</span> + show_default)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, metavar=<span class="string">&#x27;SIGMA&#x27;</span>,</span><br><span class="line">                        dest=<span class="string">&#x27;quad_sigma&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=defaults.quad_sigma,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Apply low-pass blur to input&#x27;</span> + show_default)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-0&#x27;</span>, dest=<span class="string">&#x27;refine_edges&#x27;</span>, default=<span class="literal">True</span>,</span><br><span class="line">                        action=<span class="string">&#x27;store_false&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Spend less time aligning edges of tags&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-1&#x27;</span>, dest=<span class="string">&#x27;refine_decode&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Spend more time decoding tags&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-2&#x27;</span>, dest=<span class="string">&#x27;refine_pose&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Spend more time computing pose of tags&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, dest=<span class="string">&#x27;quad_contours&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Use new contour-based quad detection&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Detector</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Pythonic wrapper for apriltag_detector. Initialize by passing in</span></span><br><span class="line"><span class="string">    the output of an argparse.ArgumentParser on which you have called</span></span><br><span class="line"><span class="string">    add_arguments; or an instance of the DetectorOptions class.  You can</span></span><br><span class="line"><span class="string">    also optionally pass in a list of paths to search for the C dynamic</span></span><br><span class="line"><span class="string">    library used by ctypes.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, options=<span class="literal">None</span>, searchpath=[]</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            options = DetectorOptions()</span><br><span class="line"></span><br><span class="line">        self.options = options</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Detect OS to get extension for DLL</span></span><br><span class="line">        uname0 = os.uname()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> uname0 == <span class="string">&#x27;Darwin&#x27;</span>:</span><br><span class="line">            extension = <span class="string">&#x27;.dylib&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            extension = <span class="string">&#x27;.so&#x27;</span></span><br><span class="line"></span><br><span class="line">        filename = <span class="string">&#x27;libapriltag&#x27;</span>+extension</span><br><span class="line"></span><br><span class="line">        self.libc = <span class="literal">None</span></span><br><span class="line">        self.tag_detector = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> searchpath:</span><br><span class="line">            relpath = os.path.join(path, filename)</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(relpath):</span><br><span class="line">                self.libc = ctypes.CDLL(relpath)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if full path not found just try opening the raw filename;</span></span><br><span class="line">        <span class="comment"># this should search whatever paths dlopen is supposed to</span></span><br><span class="line">        <span class="comment"># search.</span></span><br><span class="line">        <span class="keyword">if</span> self.libc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.libc = ctypes.CDLL(filename)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.libc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Could not find DLL named &#x27;</span> + filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># declare return types of libc function</span></span><br><span class="line">        self._declare_return_types()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create the c-_apriltag_detector object</span></span><br><span class="line">        self.tag_detector = self.libc.apriltag_detector_create()</span><br><span class="line">        self.tag_detector.contents.nthreads = <span class="built_in">int</span>(options.nthreads)</span><br><span class="line">        self.tag_detector.contents.quad_decimate = <span class="built_in">float</span>(options.quad_decimate)</span><br><span class="line">        self.tag_detector.contents.quad_sigma = <span class="built_in">float</span>(options.quad_sigma)</span><br><span class="line">        self.tag_detector.refine_edges = <span class="built_in">int</span>(options.refine_edges)</span><br><span class="line">        self.tag_detector.refine_decode = <span class="built_in">int</span>(options.refine_decode)</span><br><span class="line">        self.tag_detector.refine_pose = <span class="built_in">int</span>(options.refine_pose)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.quad_contours:</span><br><span class="line">            self.libc.apriltag_detector_enable_quad_contours(self.tag_detector, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.families = []</span><br><span class="line"></span><br><span class="line">        flist = self.libc.apriltag_family_list()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(flist.contents.size):</span><br><span class="line">            ptr = ctypes.c_char_p()</span><br><span class="line">            self.libc.zarray_get(flist, i, ctypes.byref(ptr))</span><br><span class="line">            self.families.append(ctypes.string_at(ptr))</span><br><span class="line"></span><br><span class="line">        self.libc.apriltag_family_list_destroy(flist)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> options.families == <span class="string">&#x27;all&#x27;</span>:</span><br><span class="line">            families_list = self.families</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(options.families, <span class="built_in">list</span>):</span><br><span class="line">            families_list = options.families</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            families_list = [n <span class="keyword">for</span> n <span class="keyword">in</span> re.split(<span class="string">r&#x27;\W+&#x27;</span>, options.families) <span class="keyword">if</span> n]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add tags</span></span><br><span class="line">        <span class="keyword">for</span> family <span class="keyword">in</span> families_list:</span><br><span class="line">            self.add_tag_family(family)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.tag_detector <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.libc.apriltag_detector_destroy(self.tag_detector)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect</span>(<span class="params">self, img, return_image=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run detectons on the provided image. The image must be a grayscale</span></span><br><span class="line"><span class="string">        image of type numpy.uint8.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(img.shape) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> img.dtype == numpy.uint8</span><br><span class="line"></span><br><span class="line">        c_img = self._convert_image(img)</span><br><span class="line"></span><br><span class="line">        return_info = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">#detect apriltags in the image</span></span><br><span class="line">        detections = self.libc.apriltag_detector_detect(self.tag_detector, c_img)</span><br><span class="line"></span><br><span class="line">        apriltag = ctypes.POINTER(_ApriltagDetection)()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, detections.contents.size):</span><br><span class="line"></span><br><span class="line">            <span class="comment">#extract the data for each apriltag that was identified</span></span><br><span class="line">            self.libc.zarray_get(detections, i, ctypes.byref(apriltag))</span><br><span class="line"></span><br><span class="line">            tag = apriltag.contents</span><br><span class="line"></span><br><span class="line">            homography = _matd_get_array(tag.H).copy()</span><br><span class="line">            center = numpy.ctypeslib.as_array(tag.c, shape=(<span class="number">2</span>,)).copy()</span><br><span class="line">            corners = numpy.ctypeslib.as_array(tag.p, shape=(<span class="number">4</span>, <span class="number">2</span>)).copy()</span><br><span class="line"></span><br><span class="line">            detection = Detection(</span><br><span class="line">                ctypes.string_at(tag.family.contents.name),</span><br><span class="line">                tag.<span class="built_in">id</span>,</span><br><span class="line">                tag.hamming,</span><br><span class="line">                tag.goodness,</span><br><span class="line">                tag.decision_margin,</span><br><span class="line">                homography,</span><br><span class="line">                center,</span><br><span class="line">                corners)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#Append this dict to the tag data array</span></span><br><span class="line">            return_info.append(detection)</span><br><span class="line"></span><br><span class="line">        self.libc.image_u8_destroy(c_img)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> return_image:</span><br><span class="line"></span><br><span class="line">            dimg = self._vis_detections(img.shape, detections)</span><br><span class="line">            rval = return_info, dimg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            rval = return_info</span><br><span class="line"></span><br><span class="line">        self.libc.apriltag_detections_destroy(detections)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_tag_family</span>(<span class="params">self, name</span>):</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Add a single tag family to this detector.</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        family = self.libc.apriltag_family_create(name.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> family:</span><br><span class="line">            family.contents.border = self.options.border</span><br><span class="line">            self.libc.apriltag_detector_add_family(self.tag_detector, family)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Unrecognized tag family name. Try e.g. tag36h11&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detection_pose</span>(<span class="params">self, detection, camera_params, tag_size=<span class="number">1</span>, z_sign=<span class="number">1</span></span>):</span><br><span class="line"></span><br><span class="line">        fx, fy, cx, cy = [ ctypes.c_double(c) <span class="keyword">for</span> c <span class="keyword">in</span> camera_params ]</span><br><span class="line"></span><br><span class="line">        H = self.libc.matd_create(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        arr = _matd_get_array(H)</span><br><span class="line">        arr[:] = detection.homography</span><br><span class="line">        corners = detection.corners.flatten().astype(numpy.float64)</span><br><span class="line"></span><br><span class="line">        dptr = ctypes.POINTER(ctypes.c_double)</span><br><span class="line"></span><br><span class="line">        corners = corners.ctypes.data_as(dptr)</span><br><span class="line"></span><br><span class="line">        init_error = ctypes.c_double(<span class="number">0</span>)</span><br><span class="line">        final_error = ctypes.c_double(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        Mptr = self.libc.pose_from_homography(H, fx, fy, cx, cy,</span><br><span class="line">                                              ctypes.c_double(tag_size),</span><br><span class="line">                                              ctypes.c_double(z_sign),</span><br><span class="line">                                              corners,</span><br><span class="line">                                              dptr(init_error),</span><br><span class="line">                                              dptr(final_error))</span><br><span class="line"></span><br><span class="line">        M = _matd_get_array(Mptr).copy()</span><br><span class="line">        self.libc.matd_destroy(H)</span><br><span class="line">        self.libc.matd_destroy(Mptr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> M, init_error.value, final_error.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_vis_detections</span>(<span class="params">self, shape, detections</span>):</span><br><span class="line"></span><br><span class="line">        height, width = shape</span><br><span class="line">        c_dimg = self.libc.image_u8_create(width, height)</span><br><span class="line">        self.libc.apriltag_vis_detections(detections, c_dimg)</span><br><span class="line">        tmp = _image_u8_get_array(c_dimg)</span><br><span class="line"></span><br><span class="line">        rval = tmp[:, :width].copy()</span><br><span class="line"></span><br><span class="line">        self.libc.image_u8_destroy(c_dimg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rval</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_declare_return_types</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        self.libc.apriltag_detector_create.restype = ctypes.POINTER(_ApriltagDetector)</span><br><span class="line">        self.libc.apriltag_family_create.restype = ctypes.POINTER(_ApriltagFamily)</span><br><span class="line">        self.libc.apriltag_detector_detect.restype = ctypes.POINTER(_ZArray)</span><br><span class="line">        self.libc.image_u8_create.restype = ctypes.POINTER(_ImageU8)</span><br><span class="line">        self.libc.image_u8_write_pnm.restype = ctypes.c_int</span><br><span class="line">        self.libc.apriltag_family_list.restype = ctypes.POINTER(_ZArray)</span><br><span class="line">        self.libc.apriltag_vis_detections.restype = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.libc.pose_from_homography.restype = ctypes.POINTER(_Matd)</span><br><span class="line">        self.libc.matd_create.restype = ctypes.POINTER(_Matd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_convert_image</span>(<span class="params">self, img</span>):</span><br><span class="line"></span><br><span class="line">        height = img.shape[<span class="number">0</span>]</span><br><span class="line">        width = img.shape[<span class="number">1</span>]</span><br><span class="line">        c_img = self.libc.image_u8_create(width, height)</span><br><span class="line"></span><br><span class="line">        tmp = _image_u8_get_array(c_img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># copy the opencv image into the destination array, accounting for the</span></span><br><span class="line">        <span class="comment"># difference between stride &amp; width.</span></span><br><span class="line">        tmp[:, :width] = img</span><br><span class="line"></span><br><span class="line">        <span class="comment"># tmp goes out of scope here but we don&#x27;t care because</span></span><br><span class="line">        <span class="comment"># the underlying data is still in c_img.</span></span><br><span class="line">        <span class="keyword">return</span> c_img</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_dll_path</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        os.path.join(os.path.dirname(__file__), <span class="string">&#x27;../build/lib&#x27;</span>),</span><br><span class="line">        os.path.join(os.getcwd(), <span class="string">&#x27;../build/lib&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_camera_params</span>(<span class="params">pstr</span>):</span><br><span class="line"></span><br><span class="line">    pstr = pstr.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pstr[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> pstr[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        pstr = pstr[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    params = <span class="built_in">tuple</span>( [ <span class="built_in">float</span>(param.strip()) <span class="keyword">for</span> param <span class="keyword">in</span> pstr.split(<span class="string">&#x27;,&#x27;</span>) ] )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>( <span class="built_in">len</span>(params) ==  <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_draw_pose_box</span>(<span class="params">overlay, camera_params, tag_size, pose, z_sign=<span class="number">1</span></span>):</span><br><span class="line"></span><br><span class="line">    opoints = numpy.array([</span><br><span class="line">        -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        -<span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>*z_sign,</span><br><span class="line">         <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>*z_sign,</span><br><span class="line">         <span class="number">1</span>,  <span class="number">1</span>, -<span class="number">2</span>*z_sign,</span><br><span class="line">        -<span class="number">1</span>,  <span class="number">1</span>, -<span class="number">2</span>*z_sign,</span><br><span class="line">    ]).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>) * <span class="number">0.5</span>*tag_size</span><br><span class="line"></span><br><span class="line">    edges = numpy.array([</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">7</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">4</span></span><br><span class="line">    ]).reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fx, fy, cx, cy = camera_params</span><br><span class="line"></span><br><span class="line">    K = numpy.array([fx, <span class="number">0</span>, cx, <span class="number">0</span>, fy, cy, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    rvec, _ = cv2.Rodrigues(pose[:<span class="number">3</span>,:<span class="number">3</span>])</span><br><span class="line">    tvec = pose[:<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    dcoeffs = numpy.zeros(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    ipoints, _ = cv2.projectPoints(opoints, rvec, tvec, K, dcoeffs)</span><br><span class="line"></span><br><span class="line">    ipoints = numpy.<span class="built_in">round</span>(ipoints).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    ipoints = [<span class="built_in">tuple</span>(pt) <span class="keyword">for</span> pt <span class="keyword">in</span> ipoints.reshape(-<span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> edges:</span><br><span class="line">        cv2.line(overlay, ipoints[i], ipoints[j], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_draw_pose_axes</span>(<span class="params">overlay, camera_params, tag_size, pose, center</span>):</span><br><span class="line"></span><br><span class="line">    fx, fy, cx, cy = camera_params</span><br><span class="line">    K = numpy.array([fx, <span class="number">0</span>, cx, <span class="number">0</span>, fy, cy, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    rvec, _ = cv2.Rodrigues(pose[:<span class="number">3</span>,:<span class="number">3</span>])</span><br><span class="line">    tvec = pose[:<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    dcoeffs = numpy.zeros(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    opoints = numpy.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                             [<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                             [<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>]]).reshape(-<span class="number">1</span>,<span class="number">3</span>) * tag_size</span><br><span class="line"></span><br><span class="line">    ipoints, _ = cv2.projectPoints(opoints, rvec, tvec, K, dcoeffs)</span><br><span class="line">    ipoints = numpy.<span class="built_in">round</span>(ipoints).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    center = numpy.<span class="built_in">round</span>(center).astype(<span class="built_in">int</span>)</span><br><span class="line">    center = <span class="built_in">tuple</span>(center.ravel())</span><br><span class="line"></span><br><span class="line">    cv2.line(overlay, center, <span class="built_in">tuple</span>(ipoints[<span class="number">0</span>].ravel()), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.line(overlay, center, <span class="built_in">tuple</span>(ipoints[<span class="number">1</span>].ravel()), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.line(overlay, center, <span class="built_in">tuple</span>(ipoints[<span class="number">2</span>].ravel()), (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_annotate_detection</span>(<span class="params">overlay, detection, center</span>):</span><br><span class="line"></span><br><span class="line">    text = <span class="built_in">str</span>(detection.tag_id)</span><br><span class="line">    font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">    tag_size_px = numpy.sqrt((detection.corners[<span class="number">1</span>][<span class="number">0</span>]-detection.corners[<span class="number">0</span>][<span class="number">0</span>])**<span class="number">2</span>+\</span><br><span class="line">                             (detection.corners[<span class="number">1</span>][<span class="number">1</span>]-detection.corners[<span class="number">0</span>][<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">    font_size = tag_size_px/<span class="number">22</span></span><br><span class="line">    text_size = cv2.getTextSize(text, font, font_size, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    tag_center = [detection.center[<span class="number">0</span>], detection.center[<span class="number">1</span>]]</span><br><span class="line">    text_x = <span class="built_in">int</span>(tag_center[<span class="number">0</span>] - text_size[<span class="number">0</span>]/<span class="number">2</span>)</span><br><span class="line">    text_y = <span class="built_in">int</span>(tag_center[<span class="number">1</span>] + text_size[<span class="number">1</span>]/<span class="number">2</span>)</span><br><span class="line">    cv2.putText(overlay, text, (text_x, text_y), font, font_size, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_tags</span>(<span class="params">image,</span></span><br><span class="line"><span class="params">                detector,</span></span><br><span class="line"><span class="params">                camera_params=(<span class="params"><span class="number">3156.71852</span>, <span class="number">3129.52243</span>, <span class="number">359.097908</span>, <span class="number">239.736909</span></span>),</span></span><br><span class="line"><span class="params">                tag_size=<span class="number">0.0762</span>,</span></span><br><span class="line"><span class="params">                vizualization=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">                verbose=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">                annotation=<span class="literal">False</span></span></span><br><span class="line"><span class="params">               </span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Detect AprilTags from image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:   image [image]: Input image to run detection algorithm on</span></span><br><span class="line"><span class="string">            detector [detector]: AprilTag Detector object</span></span><br><span class="line"><span class="string">            camera_params [_camera_params]: Intrinsic parameters for camera (fx, fy, cx, cy)</span></span><br><span class="line"><span class="string">            tag_size [float]: Physical size of tag in user defined units (m or mm recommended)</span></span><br><span class="line"><span class="string">            vizualization [int]: 0 - Highlight</span></span><br><span class="line"><span class="string">                                 1 - Highlight + Boxes</span></span><br><span class="line"><span class="string">                                 2 - Highlight + Axes</span></span><br><span class="line"><span class="string">                                 3 - Highlight + Boxes + Axes</span></span><br><span class="line"><span class="string">            verbose [int]: 0 - Silent</span></span><br><span class="line"><span class="string">                           1 - Number of detections</span></span><br><span class="line"><span class="string">                           2 - Detection data</span></span><br><span class="line"><span class="string">                           3 - Detection and pose data</span></span><br><span class="line"><span class="string">            annotation [bool]: Render annotated text on detection window</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(image.shape) == <span class="number">3</span>:</span><br><span class="line">        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gray = image</span><br><span class="line"></span><br><span class="line">    detections, dimg = detector.detect(gray, return_image=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(image.shape) == <span class="number">3</span>:</span><br><span class="line">        overlay = image // <span class="number">2</span> + dimg[:, :, <span class="literal">None</span>] // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        overlay = gray // <span class="number">2</span> + dimg // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    num_detections = <span class="built_in">len</span>(detections)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose==<span class="number">1</span> <span class="keyword">or</span> verbose==<span class="number">2</span> <span class="keyword">or</span> verbose==<span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Detected &#123;&#125; tags\n&#x27;</span>.<span class="built_in">format</span>(num_detections))</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    numpy.set_printoptions(suppress=<span class="literal">True</span>, formatter=&#123;<span class="string">&#x27;float_kind&#x27;</span>:<span class="string">&#x27;&#123;:0.4f&#125;&#x27;</span>.<span class="built_in">format</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, detection <span class="keyword">in</span> <span class="built_in">enumerate</span>(detections):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> verbose==<span class="number">2</span> <span class="keyword">or</span> verbose==<span class="number">3</span>:</span><br><span class="line">            <span class="built_in">print</span>( <span class="string">&#x27;Detection &#123;&#125; of &#123;&#125;:&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, num_detections))</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="built_in">print</span>(detection.tostring(indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        pose, e0, e1 = detector.detection_pose(detection, camera_params, tag_size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vizualization==<span class="number">1</span>:</span><br><span class="line">            _draw_pose_box(overlay, camera_params, tag_size, pose)</span><br><span class="line">        <span class="keyword">elif</span> vizualization==<span class="number">2</span>:</span><br><span class="line">            _draw_pose_axes(overlay, camera_params, tag_size, pose, detection.center)</span><br><span class="line">        <span class="keyword">elif</span> vizualization==<span class="number">3</span>:</span><br><span class="line">            _draw_pose_box(overlay, camera_params, tag_size, pose)</span><br><span class="line">            _draw_pose_axes(overlay, camera_params, tag_size, pose, detection.center)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> annotation==<span class="literal">True</span>:</span><br><span class="line">            _annotate_detection(overlay, detection, tag_size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> verbose==<span class="number">3</span>:</span><br><span class="line">            <span class="built_in">print</span>(detection.tostring(collections.OrderedDict([(<span class="string">&#x27;Pose&#x27;</span>,pose),</span><br><span class="line">                                                          (<span class="string">&#x27;InitError&#x27;</span>, e0),</span><br><span class="line">                                                          (<span class="string">&#x27;FinalError&#x27;</span>, e1)]),</span><br><span class="line">                                                          indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        result.extend([detection, pose, e0, e1])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, overlay</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>课程代码示例</category>
      </categories>
  </entry>
  <entry>
    <title>ME4932 科学研究与创新实践</title>
    <url>//17690.html</url>
    <content><![CDATA[<style type="text/css">
    .fancybox {
        display: inline-block;
    }
</style>
<center>
  <font size=5>
    <b>基于3D点云的特征识别算法研究</b>
  </font>
</center>
<h2 id="前言">前言</h2>
<h3 id="课题背景与研究目标">课题背景与研究目标</h3>
<p>  轨道车辆转向架在工作过程中承受着安装部件的工作载荷、制动、牵引和惯性力，对行车安全起着至关重要的作用。转向架构架大部分结构都有钢板焊接而成，而焊缝表面的几何形状会影响焊缝周围的应力及焊缝的疲劳强度；因此，转向架之间的焊缝质量直接影响转向架的性能。</p>
<p>  焊缝打磨主要有人工打磨与机器打磨两种方式。当前，此类焊缝打磨作业主要依靠人工手持角磨机以试凑方式进行打磨，效率非常低，生产环境恶劣，且难以保证打磨后焊缝外形的一致性及修磨质量，因此迫切需要实现焊缝的自动打磨。工业机器人特有的柔顺性、可编译性、适应能力强、价格低等特点使其非常适合此类打磨作业，选用工业机器人实现自动化打磨加工已经成为当前打磨作业的一个重要发展方向。借助现有的机器自动打磨技术，可以解决转向架横梁、侧梁组成平焊缝的粗磨问题。</p>
<p>  本课题将通过线激光扫描仪获取转向架的点云数据，提取出转向架焊缝的位置、厚度、宽度等信息，再通过刀具规划软件Mastercam以及机器人离线编程软件Robomaster得到打磨轨迹点，制定机器人自动打磨焊缝的加工方案，代替工人手持角磨机进行打磨作业，采用力控去除和定尺结构相结合的方法有效保证焊缝打磨后的高度大小与一致性问题。最后通过实验验证和打磨结果检测，证明本方案的可行性和适用性，为焊缝自动打磨提供一定的参考依据。</p>
<h3 id="主要研究内容与计划">主要研究内容与计划</h3>
<p>  首先，进行<b>转向架点云数据的获取</b>。研究预计采用线激光扫描仪获取转向架的点云数据，由于转向架体积较大，单次扫描过程并不能提取出所有需要的三维信息，因此需设计多次扫描过程，设计原则是既要保证扫描的完整性，也要花费尽量少的时间，以满足生产节拍的要求。</p>
<p>  其次，根据手眼标定矩阵与扫描过程对应的旋转平移矩阵，<b>将不同扫描过程的图像坐标系下的多个点云变换到机器人基坐标系下</b>。由于最初的点云数据存在噪声点、离群点以及点分布不均匀等问题，需根据焊缝特征识别算法需求在进行点云特征识别之前对点云数据进行预处理。</p>
<p>  最后，<b>提取出转向架点云数据的特征信息</b>。根据打磨需求，工控机需要输入焊缝的位置特征、厚度与宽度等信息，然后控制机器人带着打磨头运动到指定位置对焊缝进行打磨。因此，提取特征信息需根据焊缝特征来定。转向架焊缝由六条直线焊缝与四条转角焊缝组成————</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>六条直线焊缝均分布在两个平面相交形成的夹角上，故可以根据两个平面的位置信息确定直线焊缝的位置，再通过焊缝的形状特征得到焊缝的宽度与厚度；</p>
</li>
<li class="lvl-2">
<p>四条转角焊缝分布于斜圆柱面与平面相交形成的夹角上，很难直接得到焊缝的特征信息，因此采用点云配准的方法。该方法首先利用刀具规划软件Mastercam以及机器人离线编程软件Robomaster得到在某一点云下转角打磨轨迹点，再将待打磨工件的点云数据与该点云进行配准，进而得到待打磨工件四条转角焊缝的打磨轨迹点。</p>
</li>
</ul>
<h2 id="环境准备">环境准备</h2>
<h3 id="Linux系统安装">Linux系统安装</h3>
<p>  Linux相比其他操作系统，具有代码开源、内核精简、安全稳定高效、多用户多任务多线程等诸多优点，因而非常适用于编程和开发工作。<br>
  我的笔记本上已经提前装好了Ubuntu 20.04 LTS发行版，和Windows组成双系统进行日常使用。具体安装过程此处不再赘述。</p>
<h3 id="C-编程环境配置">C++编程环境配置</h3>
<h4 id="安装C-整套编译工具">安装C++整套编译工具</h4>
<p>  Ubuntu在缺省情况下，并不提供C/C++的编译环境，因此需要手动安装。Ubuntu提供了一个build-essential软件包。查看该软件包的依赖关系并安装：</p>
<p><img src="/images/ME4932-%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/screenshot1.png" alt=""></p>
<p>查看编译器、调试器的版本信息：<br>
<img src="/images/ME4932-%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/screenshot2.png" alt=""></p>
<p>使用g++编译工具对C++程序进行编译，并运行生成的可执行文件。代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行程序~~~</p>
<img src="/images/ME4932-科学研究与创新实践/screenshot3.png" width="70%"/>
<p>C++编译工具至此配置完毕！</p>
<h4 id="安装编译配置工具—CMake">安装编译配置工具—CMake</h4>
<p>  一个大型C++项目通常含有十几个类，各类间还存在复杂的依赖关系。其中一部分要编译成可执行文件，另一部分编译成库文件。若仅靠g++命令，需输入大量的编译指令，整个编译过程会变得异常繁琐。因此，对于C++项目，使用一些工程管理工具会更高效。</p>
<p>  CMake是一个跨平台的、开源的编译配置工具。CMake允许开发者编写与平台无关的CMakeLists.txt文件定制整个编译流程，然后用户通过cmake命令生成本地化Makefile文件，最后用make命令编译整个工程。本课题将使用CMake工具对C++项目进行管理。</p>
<p>附：CMake工具官网：<a href="https://cmake.org/">https://cmake.org/</a><br>
  CMakeLists快速入门教程：<a href="https://github.com/ganleiboy/CMakeTutorial">https://github.com/ganleiboy/CMakeTutorial</a></p>
<p>安装CMake工具并查询版本：<br>
<img src="/images/ME4932-科学研究与创新实践/screenshot4.png" width="70%"/></p>
<p>  CMake是一种跨平台的编译工具，比make更为高级，使用起来也更方便。CMake主要是编写CMakeLists.txt文件，编译步骤可分为两步——用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库。</p>
<p>CMakeLists.txt的结构组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 该模板适用于源文件都在文件夹/src中，头文件都在文件夹/include中，</span><br><span class="line"># 且调用第三方库的情况。</span><br><span class="line"></span><br><span class="line"># 设置运行本配置文件所需的CMake最低版本</span><br><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 设置工程名称为&quot;Demo&quot;（可随意设置）</span><br><span class="line">project(Demo)</span><br><span class="line"></span><br><span class="line"># 设定编译参数</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_BUILD_TYPE &quot;Release&quot;)  # 也可以是Debug</span><br><span class="line"></span><br><span class="line"># 设定源码列表，查找指定目录(./src)中的所有源文件，将名称全保存在DIR_SRC变量中</span><br><span class="line">aux_source_directory(./src DIR_SRC)</span><br><span class="line"></span><br><span class="line"># 设定头文件路径(./include)</span><br><span class="line">include_directories(./include)</span><br><span class="line"></span><br><span class="line"># 查找并添加OpenCV的头文件目录</span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 将源文件编译成可执行文件，文件名为main（可随便取名，保存在当前目录下）</span><br><span class="line">add_executable(main $&#123;DIR_SRC&#125;)</span><br><span class="line">target_link_libraries(main $&#123;OpenCV_LIBS&#125;)  # 可执行文件链接OpenCV库</span><br></pre></td></tr></table></figure>
<p>  cmake指向CMakeLists.txt所在目录的上一级目录，而cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个目录，专门用来编译。编译一个cmake工程的基本步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build  # 创建一个用于存放中间文件的文件夹</span><br><span class="line">cd build    # 进入build目录</span><br><span class="line">cmake ..    # 根据CMakeLists.txt对工程进行分析，生成中间文件和makefile文件</span><br><span class="line">make       # 根据生成的makefile文件编译程序，生成可执行文件和库文件]</span><br></pre></td></tr></table></figure>
<h4 id="C-C-集成开发环境—CLion">C/C++集成开发环境—CLion</h4>
<p>  我平日编程用得最多的IDE是Visual Studio Code，但在学长推荐下决定还是尝试一下CLion. 它是Jetbrains公司旗下的一款专为开发C/C++设计的跨平台IDE，以IntelliJ为基础进行设计，非常适合开发。</p>
<p>附：CLion官网：<a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a></p>
<p>  该软件经官方授权，可通过学创软件授权中心下载和使用。命令行安装步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jetbrains-toolbox-1.21.9712.tar.gz</span><br><span class="line">cd jetbrains-toolbox-1.21.9712</span><br><span class="line">./clion.sh</span><br></pre></td></tr></table></figure>
<p>通过Clion开发、编译简单的CMake项目~~~<br>
<img src="/images/ME4932-%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/screenshot5.png" alt=""></p>
<h2 id="点云PCL库入门">点云PCL库入门</h2>
<h3 id="PCL库基本介绍">PCL库基本介绍</h3>
<p>  PCL(Point Cloud Library)是在点云相关基础研究上建立起的大型跨平台开源C++编程库，它实现了大量点云相关的通用算法和高效数据结构，可以实现点云的获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建、可视化等操作。PCL在3D信息获取与处理上的地位，已然与OpenCV在2D上的地位等同。<br>
  附：PCL官网：<a href="https://pointclouds.org">https://pointclouds.org</a></p>
<h3 id="PCL库的发展历史">PCL库的发展历史</h3>
<p>  PCL起初是ROS(Robot Operating System)框架的一部分，由Radu Bogdan Rusu在德国慕尼黑工业大学读博期间开发和维护的开源项目，于2009年底由Willow Garage公司进一步开发完成。PCL主要应用于移动机器人的场景感知等研究领域。随着各算法模块的积累，于2011年独立出来，全球知名大学、研究机构加入项目，使其获得迅猛的发展，目前已发布到1.12.0版本。</p>
<h3 id="PCL及依赖库的安装">PCL及依赖库的安装</h3>
<h4 id="安装PCL依赖的第三方库">安装PCL依赖的第三方库</h4>
<p>  PCL库的安装依赖许多第三方库，如Boost、Eigen、FLANN、VTK、CUDA、OpenNI、Qhull等。安装过程极其繁琐，涉及许多库的版本问题，我在这一阶段也花了较长的时间。</p>
<p>命令行安装各种依赖（Ubuntu 20.04）~~~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git build-essential linux-libc-dev</span><br><span class="line">sudo apt-get install cmake cmake-gui</span><br><span class="line">sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev</span><br><span class="line">sudo apt-get install mpi-default-dev openmpi-bin openmpi-common</span><br><span class="line">sudo apt-get install libflann1.9 libflann-dev</span><br><span class="line">sudo apt-get install libeigen3-dev</span><br><span class="line">sudo apt-get install libboost-all-dev</span><br><span class="line">sudo apt-get install libqhull* libgtest-dev</span><br><span class="line">sudo apt-get install freeglut3-dev pkg-config</span><br><span class="line">sudo apt-get install libxmu-dev libxi-dev</span><br><span class="line">sudo apt-get install mono-complete</span><br><span class="line">sudo apt-get install libopenni2-dev</span><br></pre></td></tr></table></figure>
<h4 id="源码安装VTK库">源码安装VTK库</h4>
<p>  VTK库若用apt安装会出现.so文件缺失的情况，因此必须下载源码安装。先安装VTK库的依赖项X11和OpenGL~~~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libx11-dev libxext-dev libxtst-dev libxrender-dev libxmu-dev libxmuu-dev</span><br><span class="line">sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  然后到<a href="https://vtk.org/download/">VTK官网</a>下载源码（当前版本为9.2.2）并解压缩。在安装目录下打开命令行，输入cmake-gui打开cmake图形界面——配置“where is the source code”的路径为vtk-9.2.2所在的目录；在vtk-9.2.2目录新建build文件夹，配置“where to build the binaries”为build文件夹；勾选Grouped和Advanced，点击Configure。配置完成后提示configure done，点击generate按钮，会在build文件夹下生成工程文件。</p>
<img src="/images/ME4932-科学研究与创新实践/screenshot6.png" width="50%"/>
<p>  切换目录到vtk-9.2.2文件夹下的build文件夹，然后打开命令行，依次输入~~~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>至此VTK-9.2.2安装成功。</p>
<h4 id="安装PCL库">安装PCL库</h4>
<p>最后命令行安装pcl-1.12.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从github上克隆PCL源码</span><br><span class="line">git clone https://github.com/PointCloudLibrary/pcl.git</span><br><span class="line">cd pcl</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"># 用cmake分析整个源代码</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=None -DBUILD_GPU=ON -DBUILD_apps=ON -DBUILD_examples=ON ..</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>  编译过程中出现&quot;<strong>AUTOGEN: No valid Qt version found for target</strong>&quot;报错，需要安装qt5库以满足依赖关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential  # 安装Qt5的组件</span><br><span class="line">sudo apt-get install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools  # 安装Qt的开发工具</span><br><span class="line">sudo apt-get install qtcreator  # 安装qtcreator</span><br><span class="line">sudo apt-get install qt5*  # 安装qt</span><br></pre></td></tr></table></figure>
<p>  运行完上述所有命令后执行&quot;<strong>locate pcl-1.12</strong>&quot;，发现安装目录在/usr/local/include下，即可确认安装成功。</p>
<h4 id="测试PCL库">测试PCL库</h4>
<p>测试代码pcl_test.cpp内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/common/common_headers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/console/parse.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test PCL !!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">point_cloud_ptr</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uint8_t</span> <span class="title">r</span><span class="params">(<span class="number">255</span>)</span>, <span class="title">g</span><span class="params">(<span class="number">15</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> <span class="built_in">z</span>(<span class="number">-1.0</span>); z &lt;= <span class="number">1.0</span>; z += <span class="number">0.05</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">float</span> <span class="built_in">angle</span>(<span class="number">0.0</span>); angle &lt;= <span class="number">360.0</span>; angle += <span class="number">5.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	pcl::PointXYZRGB point;</span><br><span class="line">	point.x = <span class="number">0.5</span> * <span class="built_in">cosf</span> (pcl::<span class="built_in">deg2rad</span>(angle));</span><br><span class="line">	point.y = <span class="built_in">sinf</span> (pcl::<span class="built_in">deg2rad</span>(angle));</span><br><span class="line">	point.z = z;</span><br><span class="line">	<span class="type">uint32_t</span> rgb = (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(r) &lt;&lt; <span class="number">16</span> |</span><br><span class="line">		<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(g) &lt;&lt; <span class="number">8</span> | <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(b));</span><br><span class="line">	point.rgb = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(&amp;rgb);</span><br><span class="line">	point_cloud_ptr-&gt;points.<span class="built_in">push_back</span> (point);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (z &lt; <span class="number">0.0</span>) &#123; r -= <span class="number">12</span>; g += <span class="number">12</span>; &#125;</span><br><span class="line">      <span class="keyword">else</span>  &#123; g -= <span class="number">12</span>; b += <span class="number">12</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    point_cloud_ptr-&gt;width = (<span class="type">int</span>) point_cloud_ptr-&gt;points.<span class="built_in">size</span> ();</span><br><span class="line">    point_cloud_ptr-&gt;height = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span> <span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">    viewer.<span class="built_in">showCloud</span>(point_cloud_ptr);</span><br><span class="line">    <span class="keyword">while</span> (!viewer.<span class="built_in">wasStopped</span>())&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.6)</span><br><span class="line">project(pcl_test)</span><br><span class="line"></span><br><span class="line"># 在find_package命令前需提供PCL的cmake文件所在的目录，或者添加至环境变量</span><br><span class="line">set(PCL_DIR /usr/local/include/pcl-1.12/share/pcl-1.12)</span><br><span class="line">find_package(PCL 1.12 REQUIRED)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PCL_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;PCL_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;PCL_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(pcl_test pcl_test.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries (pcl_test $&#123;PCL_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将pcl_test.cpp和CMakeLists.txt放在一个目录下，执行如下命令：<br>
（或者直接在Clion下构建并运行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./pcl_test</span><br></pre></td></tr></table></figure>
<p>若可以看到一个漂亮的3D模型，则pcl及其依赖库安装成功⬇<br>
<img src="/images/ME4932-科学研究与创新实践/screenshot7.png" width="30%"></p>
<h2 id="转向架点云数据的获取和配准">转向架点云数据的获取和配准</h2>
<p>  柯学长布置的任务清单如下：</p>
<blockquote>
<p>项目的总体任务：<strong>提取出焊缝的特征数据</strong><br>
注：需提前思考焊缝打磨的特征数据是什么，根据自己的思考提取相应的特征数据。</p>
</blockquote>
<blockquote>
<p>现阶段的任务（10-12月）：</p>
<ul class="lvl-1">
<li class="lvl-2">点云数据的读取；</li>
<li class="lvl-2">点云数据的可视化；</li>
<li class="lvl-2">将三个点云数据通过旋转平移矩阵变换到一个坐标系下。</li>
</ul>
</blockquote>
<blockquote>
<p>文件清单说明：<br>
data1, data2, data3是扫描的点云数据。<br>
transform.txt文件里的数据分别是data1，data2，data3的相机坐标系与世界坐标系之间的旋转平移变换矩阵。</p>
</blockquote>
<h3 id="点云数据的读取">点云数据的读取</h3>
<p>  txt点云数据格式说明：每个点的坐标数据单独占据一行，每一行的三维坐标之间用空格间隔（如下图所示）。<br>
<img src="/images/ME4932-科学研究与创新实践/screenshot9.jpg" width="30%"/></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CMakeLists.txt</span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 2.6)</span><br><span class="line">project(pcl_visualize)</span><br><span class="line"></span><br><span class="line">find_package(PCL 1.12 REQUIRED)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PCL_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;PCL_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;PCL_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(pcl_visualize pcl_visualize.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries (pcl_visualize $&#123;PCL_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  点云主要通过激光扫描或双（多）目相机摄影获得，其主要信息包括三维坐标（XYZ）、激光反射强度（Intensity）和颜色信息（RGB）。根据不同应用场景，PCL库提供了诸如pcl::PointXYZ、pcl::PointXYZI、pcl::PointXYZRGB等点云数据类型。PCL的点云类为pcl::PointCloud<PointT>，其中PointT为类模板。</p>
<p>  下面这段代码通过输入文件流ifstream和字符串流stringstream，实现了从txt文本文件中读取数百万个点的三维坐标，并存储在点云实例的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcl_visualize.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateCloudFromTxt</span><span class="params">(<span class="type">const</span> std::string&amp; file_path, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从txt文件中读取三维点云数据，并存储在PCL点云实例中</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">data</span><span class="params">(file_path)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    pcl::PointXYZ point;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(data, line, <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">        <span class="function">std::stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        ss &gt;&gt; point.x;</span><br><span class="line">        ss &gt;&gt; point.y;</span><br><span class="line">        ss &gt;&gt; point.z;</span><br><span class="line">        cloud-&gt;<span class="built_in">push_back</span>(point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="点云数据的可视化">点云数据的可视化</h3>
<p>  为了能够方便地展现点云原型，或查看点云算法的运行效果，PCL提供了<b>pcl::visualization</b>库,可以通过简短的几行代码，查看点云的三维特征。下面这段代码使用了CloudViewer子类，完成点云数据的可视化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcl_visualize.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取点云</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    <span class="built_in">CreateCloudFromTxt</span>(<span class="string">&quot;../data1.txt&quot;</span>, cloud);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可视化点云</span></span><br><span class="line">    pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;cloud&quot;</span>)</span></span>;</span><br><span class="line">    viewer.<span class="built_in">showCloud</span>(cloud);</span><br><span class="line">    <span class="keyword">while</span>(!viewer.<span class="built_in">wasStopped</span>()) &#123;  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  可视化效果展示如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">点云图</th>
<th style="text-align:center">data1</th>
<th style="text-align:center">data2</th>
<th style="text-align:center">data3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">俯视图</td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot10.jpg"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot11.jpg"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot12.jpg"/></td>
</tr>
<tr>
<td style="text-align:center">侧视图</td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot13.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot14.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot15.png"/></td>
</tr>
</tbody>
</table>
<h3 id="点云数据的配准">点云数据的配准</h3>
<p>  点云的配准，即通过两点云间的旋转平移矩阵，将源点云变换到与目标点云相同的坐标系下。设原始坐标为${P_0(x_0,y_0,z_0)}$，变换后的坐标为${P(x,y,z)}$，则点的平移描述为${x=x_0+x_t}$， ${y=y_0+y_t}$， ${z=z_0+z_t}$. 令${T(x_t,y_t,z_t)}$为平移向量，则可得到${P=P_0+T}$.<br>
 点云的旋转可通过欧拉角、旋转矩阵、旋转向量、四元数等方式来表达。欧拉角定义点云分别绕XYZ三个轴进行旋转，旋转角度分别为${\alpha、\beta、\gamma}$。每做一次旋转可得一个旋转矩阵，分别对应${R_x(\alpha)、R_y(\beta)、R_z(\gamma)}$。总的旋转矩阵R等于这三个矩阵相乘。即<br>
  <img src="/images/ME4932-科学研究与创新实践/screenshot19.png" width=70%/><br>
  旋转矩阵直接定义一个三维矩阵R，相当于欧拉角乘积后的表现形式。将旋转矩阵直接左乘点云坐标即可完成变换。其中R必须是正交矩阵，且模长为1.<br>
  Eigen库有多种子类可以实现点云的变换，其中较常用到的是Matrix4f类和Affine3f类。两个类初始化后可相互转换。Matrix4f适用于已给出旋转矩阵的情况，需手动输入3x3旋转矩阵和1x3平移向量的值；Affine3f适用于仅给出欧拉角的情况，其多出了translation()和rotate()两个类函数，分别进行点云的平移和旋转运算。<br>
  以下是将三个焊缝点云数据变换至一个坐标系下的代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcl_visualize.cpp</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;pcl/common/transforms.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取点云</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//可视化点云</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过Matrix4f矩阵变换点云</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">transformed_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    Eigen::Matrix4f transform = Eigen::Matrix4f::<span class="built_in">Identity</span>();  <span class="comment">//转换矩阵初始化为单位矩阵</span></span><br><span class="line">    <span class="type">float</span> tfmatrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1650</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-455</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1365</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)</span><br><span class="line">            <span class="built_in">transform</span>(i,j) = tfmatrix[i][j];  <span class="comment">//为转换矩阵赋值</span></span><br><span class="line">            </span><br><span class="line">    pcl::<span class="built_in">transformPointCloud</span>(*cloud, *transformed_cloud, transform);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并原始点云和转换后点云</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">all_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    *all_cloud = *cloud + *transformed_cloud;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可视化全部点云</span></span><br><span class="line">    pcl::<span class="function">visualization::CloudViewer <span class="title">viewer2</span><span class="params">(<span class="string">&quot;all_cloud&quot;</span>)</span></span>;</span><br><span class="line">    viewer2.<span class="built_in">showCloud</span>(all_cloud);</span><br><span class="line">    <span class="keyword">while</span>(!viewer2.<span class="built_in">wasStopped</span>()) &#123;  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  将原始点云分别和变换后点云合并后，得到的点云图可视化效果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">data1</th>
<th style="text-align:center">data2</th>
<th style="text-align:center">data3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot16.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot17.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot18.png"/></td>
</tr>
</tbody>
</table>
<p>（注：所有变换后点云位于原始点云的右下方）</p>
<p>  将三个变换后点云合并，即可得到同坐标系下的转向架点云图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">俯视图</th>
<th style="text-align:center">侧视图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot20.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot21.png"/></td>
</tr>
</tbody>
</table>
<h2 id="通过点云滤波和分割提取平面特征">通过点云滤波和分割提取平面特征</h2>
<p>  在上一节中，已经将三个点云数据通过旋转平移变换到机器人基坐标系下，得到完整的转向架点云图。而本项目的目标是提取转向架焊缝的位置、厚度与宽度等信息。从三维空间中提取直线焊缝特征的方法有两种——1. <b>找到经过焊缝的两个平面，两平面的交线即为焊缝</b>；2. <b>找到转向架上和焊缝平行的边缘线，再求出从边缘线到焊缝的平移向量</b>。</p>
<img src="/images/ME4932-科学研究与创新实践/screenshot26.png" width="50%">
<p>  这里采用第一个思路，找出转向架的4个大平面，通过平面的交线得到直线焊缝的位置信息。平面特征的获取，可分为以下三个步骤进行——数据预处理、平面模型分割、索引滤波。</p>
<h3 id="点云数据的预处理">点云数据的预处理</h3>
<p>  初始点云存在大量噪声点、离群点，若不予以消除，会导致平面拟合模型误差增大；此外初始点云数据量较大（超过300万个点），会增加计算机内存和计算开销，降低求解效率。综合上述原因，点云数据必须进行预处理。</p>
<h4 id="点云的降采样">点云的降采样</h4>
<p>  PCL点云库提供了<b>VoxelGrid</b>类进行降采样处理，VoxelGrid类在输入点云数据上创建一个三维体素网络，网络由空间中一组微小的三维长方体构成。在每个体素中，所有存在的点将<b>近似成质心</b>，从而实现数据量的减少。</p>
<p>  点云降采样的代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// planar_segmentation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从硬盘加载点云数据</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(<span class="string">&quot;../original_cloud.pcd&quot;</span>, *cloud);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;共加载了&quot;</span> &lt;&lt; cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点云降采样</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor1;  <span class="comment">// 创建一个立体栅格对象</span></span><br><span class="line">    sor1.<span class="built_in">setInputCloud</span> (cloud);  <span class="comment">// 导入待降采样的点云</span></span><br><span class="line">    sor1.<span class="built_in">setLeafSize</span> (<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);  <span class="comment">// 设置滤波体素的栅格为1cm3的立方体</span></span><br><span class="line">    sor1.<span class="built_in">filter</span> (*filtered_cloud);  <span class="comment">// 执行降采样操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;下采样后剩余&quot;</span> &lt;&lt; filtered_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  经过上述代码，点云数据量由初始的3068795个下降至313218个，约为原来的1/10，使得平面拟合的计算量大幅减少。</p>
<h4 id="点云的离群点去除">点云的离群点去除</h4>
<p>  激光扫描通常生成不同点密度的点云数据集，且测量误差会导致稀疏的异常值，为局部点云特性的估计带来干扰。PCL点云库提供了<b>StatisticalOutlierRemoval</b>类来去除噪声点。其主要原理是：对每个点的邻域进行统计分析，计算每个点到所有相邻点的平均距离；假设得到的分布为<b>高斯分布</b>，可计算出均值μ和标准差σ；则所有与邻域距离大于 μ + std_mul*σ的点可视为离群点。（其中std_mul是标准差倍数的阈值，需根据数据集特点手动指定）</p>
<p>  去除点云离群点的代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// planar_segmentation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从硬盘加载点云数据</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 点云降采样</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 去除离群点（去噪）</span></span><br><span class="line">    pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor2;</span><br><span class="line">    sor2.<span class="built_in">setInputCloud</span>(filtered_cloud);  <span class="comment">// 导入待去噪的点云</span></span><br><span class="line">    sor2.<span class="built_in">setMeanK</span>(<span class="number">50</span>);  <span class="comment">// 设置统计平均距离的邻域点个数为50</span></span><br><span class="line">    sor2.<span class="built_in">setStddevMulThresh</span>(<span class="number">2</span>);  <span class="comment">// 设置判断是否为离群点的阀值</span></span><br><span class="line">    sor2.<span class="built_in">filter</span>(*filtered_cloud);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;去噪后剩余&quot;</span> &lt;&lt; filtered_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  经过上述代码，消除了约四千个因测量误差导致的噪声点，提高了点云表面的平滑性，为平面拟合做好了数据准备。</p>
<h3 id="点云的平面模型分割">点云的平面模型分割</h3>
<p>  对于二维平面的直线拟合，我们常常使用最小二乘算法求解；然而这一算法并不适用空间复杂点云的平面拟合，主要原因是无法预知哪些点集合归属于该平面。<br>
  空间点云普遍使用的是随机采样一致性算法（RANSAC）.与最小二乘法不同的是，该算法并非用所有初始数据去获取一初始解，然后剔除无效数据；而是使用满足可行条件的尽量少的初始数据，并使用一致性数据集扩大它，这是一种寻找模型去拟合数据的思想，在计算机视觉领域中有广泛的应用。<br>
  RANSAC平面拟合的过程如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在初始点云中随机选取三个点，计算其对应的平面方程${Ax+By+Cz+D=0}$.</p>
</li>
<li class="lvl-2">
<p>计算所有点至该平面的代数距离${d_i=|Ax_i+By_i+Cz_i+D|}$，选取阈值${d_{threshold}}$，若${d_i &lt;= d_{threshold}}$，则该点可被认为是模型内样本点(inliers)，否则为模型外样本点(outliers)，记录当前内点的个数。</p>
</li>
<li class="lvl-2">
<p>重复上述步骤，选取最佳拟合参数，即内点数量最多的平面对应的模型参数；每次迭代末尾都根据期望的误差率、最佳内点个数、总样本个数等计算迭代结束评判因子，从而决定是否停止迭代。</p>
</li>
</ul>
<p>  PCL中的<b>sample_consensus</b>模块提供了RANSAC平面拟合模型。我们可以实例化一个分割对象<b>SACSegmentation</b>，并设置方法类型为RANSAC. 根据数据集特点设置最大迭代次数和距离阈值，即可进行训练。最后通过<b>ModelCoefficients</b>类导出估计的平面参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// planar_segmentation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/ModelCoefficients.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从硬盘加载点云数据</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 点云降采样</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 去除离群点（去噪）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 平面模型分割</span></span><br><span class="line">    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;  <span class="comment">// 创建点云分割对象</span></span><br><span class="line">    pcl::<span class="function">PointIndices::Ptr <span class="title">inlier_indices</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;  <span class="comment">// 创建存储平面内点索引的对象</span></span><br><span class="line">    pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;  <span class="comment">// 创建存储模型参数的对象</span></span><br><span class="line"></span><br><span class="line">    seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">    seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);  <span class="comment">// 设置分割模型类别为平面</span></span><br><span class="line">    seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);  <span class="comment">// 使用随机采样一致性算法（RANSAC）</span></span><br><span class="line">    seg.<span class="built_in">setMaxIterations</span>(<span class="number">1000</span>);  <span class="comment">// 设置最大迭代次数</span></span><br><span class="line">    seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">1.5</span>);  <span class="comment">// 设置距离阈值，与平面距离小于1.5的点作为内点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, nr_points = (<span class="type">int</span>)filtered_cloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (filtered_cloud-&gt;points.<span class="built_in">size</span>() &gt; <span class="number">0.45</span> * nr_points)  <span class="comment">// 当还有至少45%的原始点云数据时</span></span><br><span class="line">    &#123;</span><br><span class="line">        seg.<span class="built_in">setInputCloud</span>(filtered_cloud);  <span class="comment">// 导入待分割点云</span></span><br><span class="line">        seg.<span class="built_in">segment</span>(*inlier_indices, *coefficients);  <span class="comment">// 执行分割操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inlier_indices-&gt;indices.<span class="built_in">size</span> () == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;无法从指定数据集中拟合平面模型！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个平面方程为：&quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;x + &quot;</span></span><br><span class="line">                  &lt;&lt; coefficients-&gt;values[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;y + &quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;z +  &quot;</span></span><br><span class="line">                  &lt;&lt; coefficients-&gt;values[<span class="number">3</span>] &lt;&lt; <span class="string">&quot; = 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                  ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注：上述代码的输出放在了小节总结里）</p>
<h3 id="点云的索引滤波">点云的索引滤波</h3>
<p>  在前一小节中，通过segment分割操作已经获得内点对应的索引inlier_indices，接下来可借助PCL库中的<b>extract_indices</b>滤波器完成对索引的滤波。<br>
  由于有多个平面需要拟合，此处的“分割+索引滤波”操作也可分多步进行——通过设置extract.setNegative的值决定选取内点或外点，每次迭代前将估计出的外点作为转向架点云进行训练，直至剩余点数低于初始点数的45%为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// planar_segmentation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从硬盘加载点云数据</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 点云降采样</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 去除离群点（去噪）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 平面模型分割</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>() &#123;</span><br><span class="line">    	...</span><br><span class="line">      <span class="comment">// 索引滤波器滤波</span></span><br><span class="line">      <span class="comment">// 分离内点</span></span><br><span class="line">      pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;  <span class="comment">// 创建索引滤波器对象</span></span><br><span class="line">      pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">inlier_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">      extract.<span class="built_in">setInputCloud</span>(filtered_cloud);</span><br><span class="line">      extract.<span class="built_in">setIndices</span>(inlier_indices);</span><br><span class="line">      extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);  <span class="comment">// false表示选取内点</span></span><br><span class="line">      extract.<span class="built_in">filter</span>(*inlier_cloud);  <span class="comment">// 执行滤波操作</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;内点总数为: &quot;</span> &lt;&lt; inlier_cloud-&gt;width * inlier_cloud-&gt;height &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 提取外点</span></span><br><span class="line">      pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">outlier_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">      extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);  <span class="comment">// true表示选取外点</span></span><br><span class="line">      extract.<span class="built_in">filter</span>(*outlier_cloud);  <span class="comment">// 滤波操作</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;外点总数为: &quot;</span> &lt;&lt; outlier_cloud-&gt;width * outlier_cloud-&gt;height &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将分割得到的平面点云保存至硬盘</span></span><br><span class="line">      std::stringstream ss1, ss2;</span><br><span class="line">      ss1 &lt;&lt; <span class="string">&quot;inliercloud_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">      ss2 &lt;&lt; <span class="string">&quot;outliercloud_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">      pcl::io::<span class="built_in">savePCDFileASCII</span>(ss1.<span class="built_in">str</span>(), *inlier_cloud);</span><br><span class="line">      pcl::io::<span class="built_in">savePCDFileASCII</span>(ss2.<span class="built_in">str</span>(), *outlier_cloud);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将外点作为新点云迭代得到多个平面</span></span><br><span class="line">      filtered_cloud.<span class="built_in">swap</span>(outlier_cloud);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="小节总结">小节总结</h3>
<p>  本小节使用的所有源代码整理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(planar_segmentation)</span><br><span class="line"></span><br><span class="line">find_package(PCL 1.2 REQUIRED)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;PCL_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;PCL_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;PCL_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable (planar_segmentation planar_segmentation.cpp)</span><br><span class="line">target_link_libraries (planar_segmentation $&#123;PCL_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// planar_segmentation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/ModelCoefficients.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从硬盘加载点云数据</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(<span class="string">&quot;../original_cloud.pcd&quot;</span>, *cloud);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;共加载了&quot;</span> &lt;&lt; cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点云降采样</span></span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor1;  <span class="comment">// 创建一个立体栅格对象</span></span><br><span class="line">    sor1.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">// 导入待降采样的点云</span></span><br><span class="line">    sor1.<span class="built_in">setLeafSize</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);  <span class="comment">// 设置滤波体素的栅格为1cm3的立方体</span></span><br><span class="line">    sor1.<span class="built_in">filter</span>(*filtered_cloud);  <span class="comment">// 执行降采样操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;下采样后剩余&quot;</span> &lt;&lt; filtered_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除离群点（去噪）</span></span><br><span class="line">    pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor2;</span><br><span class="line">    sor2.<span class="built_in">setInputCloud</span>(filtered_cloud);  <span class="comment">// 导入待去噪的点云</span></span><br><span class="line">    sor2.<span class="built_in">setMeanK</span>(<span class="number">50</span>);  <span class="comment">// 设置统计平均距离的邻域点个数为50</span></span><br><span class="line">    sor2.<span class="built_in">setStddevMulThresh</span>(<span class="number">2</span>);  <span class="comment">// 设置判断是否为离群点的阀值</span></span><br><span class="line">    sor2.<span class="built_in">filter</span>(*filtered_cloud);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-&gt;去噪后剩余&quot;</span> &lt;&lt; filtered_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个数据点&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平面模型分割</span></span><br><span class="line">    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;  <span class="comment">// 创建点云分割对象</span></span><br><span class="line">    pcl::<span class="function">PointIndices::Ptr <span class="title">inlier_indices</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;  <span class="comment">// 创建存储平面内点索引的对象</span></span><br><span class="line">    pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span><span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;  <span class="comment">// 创建存储模型参数的对象</span></span><br><span class="line"></span><br><span class="line">    seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">    seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);  <span class="comment">// 设置分割模型类别为平面</span></span><br><span class="line">    seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);  <span class="comment">// 使用随机采样一致性算法（RANSAC）</span></span><br><span class="line">    seg.<span class="built_in">setMaxIterations</span>(<span class="number">1000</span>);  <span class="comment">// 设置最大迭代次数</span></span><br><span class="line">    seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">1.5</span>);  <span class="comment">// 设置距离阈值，与平面距离小于1.5的点作为内点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, nr_points = (<span class="type">int</span>)filtered_cloud-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (filtered_cloud-&gt;points.<span class="built_in">size</span>() &gt; <span class="number">0.45</span> * nr_points)  <span class="comment">// 当还有至少45%的原始点云数据时</span></span><br><span class="line">    &#123;</span><br><span class="line">        seg.<span class="built_in">setInputCloud</span>(filtered_cloud);  <span class="comment">// 导入待分割点云</span></span><br><span class="line">        seg.<span class="built_in">segment</span>(*inlier_indices, *coefficients);  <span class="comment">// 执行分割操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inlier_indices-&gt;indices.<span class="built_in">size</span> () == <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;无法从指定数据集中拟合平面模型！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;个平面方程为：&quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;x + &quot;</span></span><br><span class="line">                  &lt;&lt; coefficients-&gt;values[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;y + &quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;z +  &quot;</span></span><br><span class="line">                  &lt;&lt; coefficients-&gt;values[<span class="number">3</span>] &lt;&lt; <span class="string">&quot; = 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引滤波器滤波</span></span><br><span class="line">        <span class="comment">// 分离内点</span></span><br><span class="line">        pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;  <span class="comment">// 创建索引滤波器对象</span></span><br><span class="line">        pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">inlier_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">        extract.<span class="built_in">setInputCloud</span>(filtered_cloud);</span><br><span class="line">        extract.<span class="built_in">setIndices</span>(inlier_indices);</span><br><span class="line">        extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);  <span class="comment">// false表示选取内点</span></span><br><span class="line">        extract.<span class="built_in">filter</span>(*inlier_cloud);  <span class="comment">// 执行滤波操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;内点总数为: &quot;</span> &lt;&lt; inlier_cloud-&gt;width * inlier_cloud-&gt;height &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取外点</span></span><br><span class="line">        pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">outlier_cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);  <span class="comment">// true表示选取外点</span></span><br><span class="line">        extract.<span class="built_in">filter</span>(*outlier_cloud);<span class="comment">// 滤波操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;外点总数为: &quot;</span> &lt;&lt; outlier_cloud-&gt;width * outlier_cloud-&gt;height &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将分割得到的平面点云保存至硬盘</span></span><br><span class="line">        std::stringstream ss1, ss2;</span><br><span class="line">        ss1 &lt;&lt; <span class="string">&quot;inliercloud_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">        ss2 &lt;&lt; <span class="string">&quot;outliercloud_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">        pcl::io::<span class="built_in">savePCDFileASCII</span>(ss1.<span class="built_in">str</span>(), *inlier_cloud);</span><br><span class="line">        pcl::io::<span class="built_in">savePCDFileASCII</span>(ss2.<span class="built_in">str</span>(), *outlier_cloud);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将外点作为新点云迭代得到多个平面</span></span><br><span class="line">        filtered_cloud.<span class="built_in">swap</span>(outlier_cloud);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  源代码所有输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt;共加载了3068795个数据点</span><br><span class="line">-&gt;下采样后剩余313218个数据点</span><br><span class="line">-&gt;去噪后剩余309175个数据点</span><br><span class="line">第1个平面方程为：-0.359203x + 0.00140967y + 0.933258z +  -641.473 = 0</span><br><span class="line">内点总数为: 81926</span><br><span class="line">外点总数为: 227249</span><br><span class="line">第2个平面方程为：-0.00400156x + -0.964687y + -0.26337z +  89.7737 = 0</span><br><span class="line">内点总数为: 30474</span><br><span class="line">外点总数为: 196775</span><br><span class="line">第3个平面方程为：0.998895x + 0.00199732y + -0.0469618z +  -1451.53 = 0</span><br><span class="line">内点总数为: 34455</span><br><span class="line">外点总数为: 162320</span><br><span class="line">第4个平面方程为：0.00321649x + -0.957514y + 0.28837z +  -954.657 = 0</span><br><span class="line">内点总数为: 25908</span><br><span class="line">外点总数为: 136412</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  将求解得到的四个平面做上色处理，再与转向架其余点云合并，得到如下效果图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">俯视图</th>
<th style="text-align:center">侧视图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot22.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot23.png"/></td>
</tr>
<tr>
<td style="text-align:center"><b>前视图</b></td>
<td style="text-align:center"><b>后视图</b></td>
</tr>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot25.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot24.png"/></td>
</tr>
</tbody>
</table>
<h2 id="通过平面法线估计和边缘检测提取焊缝特征">通过平面法线估计和边缘检测提取焊缝特征</h2>
<p>  在前一节中，我们成功拟合并提取出四个关键平面的点云集合。由于焊缝多数位于上述平面的边缘，因而可以通过法线估计+边缘检测提取所有的平面边缘，再通过设置合理的坐标阈值滤去不是焊缝的点。</p>
<h3 id="计算点云的平均点间距">计算点云的平均点间距</h3>
<p>  平面法线估计的一个重要参数是<b>邻域半径</b>的选择，邻域半径设置得过小，法线参数易受噪声点的影响而出错；邻域半径设置得过大，会使估计速度变慢，且不利于平面边界的判断。<br>
  在计算平面法线之前，有必要统计出点云的平均点距离，以便确定邻域半径的大致范围。PCL库提供了k维树结构，用于三维点云的距离和最近邻搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MeanDistance.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/kdtree/kdtree_flann.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(<span class="string">&quot;../inliercloud_1.pcd&quot;</span>, *cloud);</span><br><span class="line"></span><br><span class="line">    pcl::search::KdTree&lt;pcl::PointXYZ&gt; tree;  <span class="comment">// 实例化一个Kd树对象</span></span><br><span class="line">    tree.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">// 设置输入点云</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算平均点间距</span></span><br><span class="line">    <span class="type">double</span> meanDistance = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">indices</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">sqr_distances</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (tree.<span class="built_in">nearestKSearch</span>(cloud-&gt;points[i], <span class="number">2</span>, indices, sqr_distances) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// K近邻查找的成员函数，将目标点的最近邻索引和平方距离存储在容器中，返回找到的邻域数量</span></span><br><span class="line">            meanDistance += <span class="built_in">sqrt</span>(sqr_distances[<span class="number">1</span>]);</span><br><span class="line">    meanDistance /= cloud-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;平均点间距: &quot;</span> &lt;&lt; meanDistance &lt;&lt; <span class="string">&quot; cm&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  计算得到的平均点间距为0.652724cm，邻域半径设置为分辨率的10倍左右时，法线估计效果较好，故取邻域半径为5.</p>
<h3 id="基于法线估计实现的PCL边界检测与提取">基于法线估计实现的PCL边界检测与提取</h3>
<h4 id="法线估计">法线估计</h4>
<p>  表面法线是几何体表面的重要属性，在计算机视觉领域有广泛应用（例如，通过阴影和其他视觉影响推断光源的位置）。法线估计的思路大致有以下两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从已获取的点云数据集中得到潜在表面，并用表面网格化技术，来计算网格的表面法线。</p>
</li>
<li class="lvl-2">
<p>使用近似值直接从点云数据集中推断表面法线。</p>
</li>
</ul>
<p>  PCL采用了较简单的第二种思路，即将点的法线估计问题近似为估计与曲面相切的平面法线问题，进而转化为最小二乘平面拟合估计问题。因此，表面法线估计问题最终可简化为，对从一个协方差矩阵的特征向量和特征值的分析（也称PCA主成分分析）。这个协方差矩阵是由查询点的最近邻产生的。对于每个点Pi,我们假设协方差矩阵C如下：</p>
<p>$${C=\frac{1}{k}\sum_{i=1}{k\left(p_i-\bar{p}\right)\bullet\left(p_i-\bar{p}\right)T},C\bullet\vec{v_j}=\lambda_j\bullet\vec{v_j},j\in0,1,2}$$</p>
<p>  其中K指的是离${p_i}$点最近的K个点，${\bar{p}}$是最近邻的中心，${\lambda_j}$是第j个特征值，${\vec{v_j}}$是第j个特征向量。</p>
<p>  接下来我们需解决法线方向的问题。以球面为例，法线可以指向球心，也可以背向球心。对于图像中的物体表面，只有法线全部朝向表面一侧才有助于表面特征的分析。因而我们引入视角向量这一概念，只要法线和  视角与点的连线的夹角是锐角，即计算向量点积。若点积小于0，将向量转向即可。</p>
<p>  PCL库提供了<b>NormalEstimation</b>类来估计点的法向向量。该类的成员函数先得到点p的N个最近邻，再计算p的表面法线${\vec{n}}$，最后检查检查${\vec{n}}$的方向是否一致指向视点，如果不是则翻转。</p>
<h4 id="边界估计">边界估计</h4>
<p>  法线估计为平面边缘检测任务提供了充分的判定依据。对于一个二维平面，边缘点的法线向量往往与其他点差异巨大。通过设置合理的角度阈值（如本项目将阈值设为45°），可以轻松标记出平面的边缘轮廓。<br>
  PCL库提供了<b>BoundaryEstimation</b>类以执行边界估计操作。上两个小节的代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boundEst.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/features/normal_3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/features/boundary.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/kdtree/kdtree_flann.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_boundaries</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从硬盘中依次加载三个平面点云</span></span><br><span class="line">        pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;../inliercloud_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">        pcl::io::<span class="built_in">loadPCDFile</span>(ss.<span class="built_in">str</span>(), *cloud);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 法线估计</span></span><br><span class="line">        pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; normEst;  <span class="comment">// 定义一个法线估计的对象</span></span><br><span class="line">        pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;  <span class="comment">// 保存法线估计的结果</span></span><br><span class="line">        normEst.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">// 设置输入点云</span></span><br><span class="line">        normEst.<span class="built_in">setRadiusSearch</span>(<span class="number">5</span>);  <span class="comment">// 设置领域搜索球半径为5cm</span></span><br><span class="line">        normEst.<span class="built_in">compute</span>(*normals);  <span class="comment">// 执行法线估计</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界估计</span></span><br><span class="line">        pcl::BoundaryEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::Boundary&gt; boundEst;</span><br><span class="line">        pcl::PointCloud&lt;pcl::Boundary&gt; boundaries;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        boundEst.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">// 设置输入点云</span></span><br><span class="line">        boundEst.<span class="built_in">setInputNormals</span>(normals);  <span class="comment">// 设置边界估计依赖的法线</span></span><br><span class="line">        boundEst.<span class="built_in">setKSearch</span>(<span class="number">50</span>);  <span class="comment">// 设置一次边界估计用到的邻域点数为50</span></span><br><span class="line">        boundEst.<span class="built_in">setAngleThreshold</span>(M_PI/<span class="number">4</span>); <span class="comment">// 设置边界估计的角度阈值</span></span><br><span class="line">        boundEst.<span class="built_in">setSearchMethod</span>(tree);  <span class="comment">// 设置搜索方式为KdTree</span></span><br><span class="line">        boundEst.<span class="built_in">compute</span>(boundaries);  <span class="comment">// 执行边界估计</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将边界结果保存为pcl::PointXYZ类型</span></span><br><span class="line">        pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_boundary</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(boundaries[i].boundary_point &gt; <span class="number">0</span>)</span><br><span class="line">                cloud_boundary-&gt;<span class="built_in">push_back</span>(cloud-&gt;points[i]);</span><br><span class="line"></span><br><span class="line">        *cloud_boundaries += *cloud_boundary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileASCII</span>(<span class="string">&quot;cloud_boundaries.pcd&quot;</span>, *cloud_boundaries);</span><br><span class="line">    pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;cloud&quot;</span>)</span></span>;</span><br><span class="line">    viewer.<span class="built_in">showCloud</span>(cloud_boundaries);</span><br><span class="line">    <span class="keyword">while</span>(!viewer.<span class="built_in">wasStopped</span>()) &#123; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  转向架的边界轮廓提取效果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">边界检测效果图</th>
<th style="text-align:center">提取边界后的点云图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot27.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot28.png"/></td>
</tr>
</tbody>
</table>
<h3 id="直通滤波保留符合焊缝特征的边缘">直通滤波保留符合焊缝特征的边缘</h3>
<h2 id="转向架圆角焊缝的提取">转向架圆角焊缝的提取</h2>
<p>  圆角焊缝的提取相较于直线焊缝困难不少，原因在于圆角过渡区的几何特征未知，无法通过模型拟合的方式进行估算。但是利用转向架各个曲面的几何约束关系，我们不妨利用<b>排除法</b>得到圆角焊缝的点云集合。这里作两点假设：1. 圆角过渡区为光滑的外凸曲面；2. 圆角焊缝和直角焊缝关于地面的投影为一直线。</p>
<h3 id="获取圆角区域的位置信息">获取圆角区域的位置信息</h3>
<p>  若以上假设成立，我们通过前文得到的直角焊缝的位置信息，即可确定圆角焊缝的位置信息。以下程序<b>showPointXYZ.cpp</b>允许用户与PCLVisualizer的可视化界面进行交互，当用户选中一个点时，该点的坐标会被打印到控制台，并且在可视化界面中以红色高亮显示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// showPointXYZ.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PointT = pcl::PointXYZRGB;</span><br><span class="line"><span class="keyword">using</span> PointCloudT = pcl::PointCloud&lt;PointT&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将参数传递给回调函数的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CallbackArgs</span> &#123;</span><br><span class="line">    PointCloudT::Ptr clicked_points_3d;</span><br><span class="line">    pcl::visualization::PCLVisualizer::Ptr viewerPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pickPointCallback</span><span class="params">(<span class="type">const</span> pcl::visualization::PointPickingEvent &amp;event, <span class="type">void</span> *args)</span> </span>&#123;</span><br><span class="line">    CallbackArgs *data = (CallbackArgs *) args;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="built_in">getPointIndex</span>() == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PointT current_point;</span><br><span class="line">    event.<span class="built_in">getPoint</span>(current_point.x, current_point.y, current_point.z);</span><br><span class="line">    data-&gt;clicked_points_3d-&gt;points.<span class="built_in">push_back</span>(current_point);</span><br><span class="line">    <span class="comment">// 绘制红色点</span></span><br><span class="line">    pcl::<span class="function">visualization::PointCloudColorHandlerCustom&lt;PointT&gt; <span class="title">red</span><span class="params">(data-&gt;clicked_points_3d, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    data-&gt;viewerPtr-&gt;<span class="built_in">removePointCloud</span>(<span class="string">&quot;clicked_points&quot;</span>);</span><br><span class="line">    data-&gt;viewerPtr-&gt;<span class="built_in">addPointCloud</span>(data-&gt;clicked_points_3d, red, <span class="string">&quot;clicked_points&quot;</span>);</span><br><span class="line">    data-&gt;viewerPtr-&gt;<span class="built_in">setPointCloudRenderingProperties</span>(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, <span class="number">10</span>,</span><br><span class="line">                                                      <span class="string">&quot;clicked_points&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; current_point.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current_point.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current_point.z &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">file_name</span><span class="params">(<span class="string">&quot;../colored_cloud.pcd&quot;</span>)</span></span>;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;())</span></span>;</span><br><span class="line">    pcl::visualization::<span class="function">PCLVisualizer::Ptr <span class="title">viewer</span><span class="params">(<span class="keyword">new</span> pcl::visualization::PCLVisualizer(<span class="string">&quot;viewer&quot;</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 加载点云</span></span><br><span class="line">    <span class="keyword">if</span> (pcl::io::<span class="built_in">loadPCDFile</span>(file_name, *cloud) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;could not load file: &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; cloud-&gt;points.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 显示点云</span></span><br><span class="line">    viewer-&gt;<span class="built_in">addPointCloud</span>(cloud, <span class="string">&quot;cloud&quot;</span>);</span><br><span class="line">    viewer-&gt;<span class="built_in">setCameraPosition</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 添加点拾取回调函数</span></span><br><span class="line">    CallbackArgs  cb_args;</span><br><span class="line">    <span class="function">PointCloudT::Ptr <span class="title">clicked_points_3d</span><span class="params">(<span class="keyword">new</span> PointCloudT)</span></span>;</span><br><span class="line">    cb_args.clicked_points_3d = clicked_points_3d;</span><br><span class="line">    cb_args.viewerPtr = pcl::visualization::PCLVisualizer::<span class="built_in">Ptr</span>(viewer);</span><br><span class="line">    viewer-&gt;<span class="built_in">registerPointPickingCallback</span>(pickPointCallback, (<span class="type">void</span>*)&amp;cb_args);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shift+click on three floor points, then press &#x27;Q&#x27;...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    viewer-&gt;<span class="built_in">spin</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!viewer-&gt;<span class="built_in">wasStopped</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        viewer-&gt;<span class="built_in">spinOnce</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  下面是拾取焊缝边缘点的结果</p>
<table>
<thead>
<tr>
<th style="text-align:center">侧架1边缘点扫描</th>
<th style="text-align:center">侧架2边缘点扫描</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot29.png"/></td>
<td style="text-align:center"><img src="/images/ME4932-科学研究与创新实践/screenshot30.png"/></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcl_passthrough.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/filters/passthrough.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_filtered</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    pcl::io::<span class="built_in">loadPCDFile</span>(<span class="string">&quot;../all_cloud.pcd&quot;</span>, *cloud);</span><br><span class="line"></span><br><span class="line">    pcl::PassThrough&lt;pcl::PointXYZ&gt; pass_x, pass_y, pass_z; <span class="comment">//创建滤波器对象</span></span><br><span class="line">    pass_x.<span class="built_in">setInputCloud</span>(cloud);			                <span class="comment">//设置待滤波的点云</span></span><br><span class="line">    pass_x.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;x&quot;</span>);		        <span class="comment">//设置在X轴方向上进行滤波</span></span><br><span class="line">    pass_x.<span class="built_in">setFilterLimits</span>(<span class="number">1535.0</span>, <span class="number">1740.0</span>);		<span class="comment">//设置滤波范围为0~1,在范围之外的点会被剪除</span></span><br><span class="line">    <span class="comment">//pass.setFilterLimitsNegative(true);                   //是否反向过滤，默认为false</span></span><br><span class="line">    pass_x.<span class="built_in">filter</span>(*cloud_filtered);		                <span class="comment">//开始过滤</span></span><br><span class="line"></span><br><span class="line">    pass_y.<span class="built_in">setInputCloud</span>(cloud_filtered);			    <span class="comment">//设置待滤波的点云</span></span><br><span class="line">    pass_y.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;y&quot;</span>);		        <span class="comment">//设置在Y轴方向上进行滤波</span></span><br><span class="line">    pass_y.<span class="built_in">setFilterLimits</span>(<span class="number">-320.0</span>, <span class="number">-250.0</span>);		<span class="comment">//设置滤波范围为0~1,在范围之外的点会被剪除</span></span><br><span class="line">    <span class="comment">//pass.setFilterLimitsNegative(true);                   //是否反向过滤，默认为false</span></span><br><span class="line">    pass_y.<span class="built_in">filter</span>(*cloud_filtered);		                <span class="comment">//开始过滤</span></span><br><span class="line"></span><br><span class="line">    pass_z.<span class="built_in">setInputCloud</span>(cloud_filtered);			    <span class="comment">//设置待滤波的点云</span></span><br><span class="line">    pass_z.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);		        <span class="comment">//设置在Z轴方向上进行滤波</span></span><br><span class="line">    pass_z.<span class="built_in">setFilterLimits</span>(<span class="number">1232.0</span>, <span class="number">1360.0</span>);		<span class="comment">//设置滤波范围为0~1,在范围之外的点会被剪除</span></span><br><span class="line">    <span class="comment">//pass.setFilterLimitsNegative(true);                   //是否反向过滤，默认为false</span></span><br><span class="line">    pass_z.<span class="built_in">filter</span>(*cloud_filtered);		                <span class="comment">//开始过滤</span></span><br><span class="line"></span><br><span class="line">    pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;filtered_cloud&quot;</span>)</span></span>;</span><br><span class="line">    viewer.<span class="built_in">showCloud</span>(cloud_filtered);</span><br><span class="line">    <span class="keyword">while</span>(!viewer.<span class="built_in">wasStopped</span>())  &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/images/ME4932-科学研究与创新实践/screenshot31.png" width="50%">]]></content>
      <categories>
        <category>课程代码示例</category>
      </categories>
  </entry>
</search>
